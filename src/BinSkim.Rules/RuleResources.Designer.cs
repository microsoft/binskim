//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Microsoft.CodeAnalysis.IL.Rules {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class RuleResources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal RuleResources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Microsoft.CodeAnalysis.IL.Rules.RuleResources", typeof(RuleResources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is a 64-bit image with a preferred base address below the 4GB boundary. Having a preferred base address below this boundary triggers a compatibility mode in Address Space Layout Randomization (ASLR) on recent versions of Windows that reduces the number of locations to which ASLR may relocate the binary. This reduces the effectiveness of ASLR at mitigating memory corruption vulnerabilities. To resolve this issue, either use the default preferred base address by removing any uses of /baseaddress from co [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BA2001_Error {
            get {
                return ResourceManager.GetString("BA2001_Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 64-bit images should have a preferred base address above the 4GB boundary to prevent triggering an Address Space Layout Randomization (ASLR) compatibility mode that decreases security. ASLR compatibility mode reduces the number of locations to which ASLR may relocate the binary, reducing its effectiveness at mitigating memory corruption vulnerabilities. To resolve this issue, either use the default preferred base address by removing any uses of /baseaddress from compiler command lines, or /BASE from linker  [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BA2001_LoadImageAboveFourGigabyteAddress_Description {
            get {
                return ResourceManager.GetString("BA2001_LoadImageAboveFourGigabyteAddress_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is a 64-bit image with a base address that is &gt;= 4 gigabytes, increasing the effectiveness of Address Space Layout Randomization (which helps prevent attackers from executing security-sensitive code in well-known locations)..
        /// </summary>
        internal static string BA2001_Pass {
            get {
                return ResourceManager.GetString("BA2001_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Binaries should not take dependencies on code with known security vulnerabilities..
        /// </summary>
        internal static string BA2002_DoNotIncorporateVulnerableBinaries_Description {
            get {
                return ResourceManager.GetString("BA2002_DoNotIncorporateVulnerableBinaries_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; was built with a version of {1} which is subject to the following issues: {2}. To resolve this, {3}. The source files that triggered this were: {4}.
        /// </summary>
        internal static string BA2002_Error {
            get {
                return ResourceManager.GetString("BA2002_Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; does not incorporate any known vulnerable dependencies, as configured by current policy..
        /// </summary>
        internal static string BA2002_Pass {
            get {
                return ResourceManager.GetString("BA2002_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Compilers can generate and store checksums of source files in order to provide linkage between binaries, their PDBs, and associated source code. This information is typically used to resolve source file when debugging but it can also be used to verify that a specific body of source code is, in fact, the code that was used to produce a specific set of binaries and PDBs. This validation is helpful in verifying supply chain integrity. Due to this security focus, it is important that the hashing algorithm used  [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BA2004_EnableSecureSourceCodeHashing_Description {
            get {
                return ResourceManager.GetString("BA2004_EnableSecureSourceCodeHashing_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is a managed binary compiled with an insecure (SHA-1) source code hashing algorithm. SHA-1 is subject to collision attacks and its use can compromise supply chain integrity. Pass &apos;-checksumalgorithm:SHA256&apos; on the csc.exe command-line or populate the project &lt;ChecksumAlgorithm&gt; property with &apos;SHA256&apos; to enable secure source code hashing..
        /// </summary>
        internal static string BA2004_Error_Managed {
            get {
                return ResourceManager.GetString("BA2004_Error_Managed", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is a native binary that directly compiles and links one or more object files which were hashed using an insecure checksum algorithm (MD5). MD5 is subject to collision attacks and its use can compromise supply chain integrity. Pass &apos;/ZH:SHA_256&apos; on the cl.exe command-line to enable secure source code hashing. The following modules are out of policy:
        ///{1}.
        /// </summary>
        internal static string BA2004_Error_NativeWithInsecureDirectCompilands {
            get {
                return ResourceManager.GetString("BA2004_Error_NativeWithInsecureDirectCompilands", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is a {1} binary which was compiled with a secure (SHA-256) source code hashing algorithm..
        /// </summary>
        internal static string BA2004_Pass {
            get {
                return ResourceManager.GetString("BA2004_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is a native binary that links one or more static libraries that include object files which were hashed using an insecure checksum algorithm (MD5). MD5 is subject to collision attacks and its use can compromise supply chain integrity. Pass &apos;/ZH:SHA_256&apos; on the cl.exe command-line to enable secure source code hashing. The following modules are out of policy:
        ///{1}.
        /// </summary>
        internal static string BA2004_Warning_NativeWithInsecureStaticLibraryCompilands {
            get {
                return ResourceManager.GetString("BA2004_Warning_NativeWithInsecureStaticLibraryCompilands", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not ship obsolete libraries for which there are known security vulnerabilities..
        /// </summary>
        internal static string BA2005_DoNotShipVulnerableBinaries_Description {
            get {
                return ResourceManager.GetString("BA2005_DoNotShipVulnerableBinaries_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; appears to be an obsolete library (version {1}) for which there are known security vulnerabilities. To resolve this issue, obtain a version of {0} that is newer than version {2}. If this binary is not in fact {0}, ignore this warning..
        /// </summary>
        internal static string BA2005_Error {
            get {
                return ResourceManager.GetString("BA2005_Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Version information for &apos;{0}&apos; could not be parsed. The binary therefore could not be verified not to be an obsolete binary that is known to be vulnerable to one or more security problems..
        /// </summary>
        internal static string BA2005_Error_CouldNotParseVersion {
            get {
                return ResourceManager.GetString("BA2005_Error_CouldNotParseVersion", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to vulnerable binary name and version metadata.
        /// </summary>
        internal static string BA2005_MissingRequiredConfiguration {
            get {
                return ResourceManager.GetString("BA2005_MissingRequiredConfiguration", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is not known to be an obsolete binary that is vulnerable to one or more security problems..
        /// </summary>
        internal static string BA2005_Pass {
            get {
                return ResourceManager.GetString("BA2005_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Application code should be compiled with the most up-to-date tool sets possible to take advantage of the most current compile-time security features. Among other things, these features provide address space layout randomization, help prevent arbitrary code execution, and enable code generation that can help prevent speculative execution side-channel attacks..
        /// </summary>
        internal static string BA2006_BuildWithSecureTools_Description {
            get {
                return ResourceManager.GetString("BA2006_BuildWithSecureTools_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; was compiled with one or more modules which were not built using minimum required tool versions (compiler version {1}). More recent toolchains contain mitigations that make it more difficult for an attacker to exploit vulnerabilities in programs they produce. To resolve this issue, compile and/or link your binary with more recent tools. If you are servicing a product where the tool chain cannot be modified (e.g. producing a hotfix for an already shipped version) ignore this warning. Modules built outs [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BA2006_Error {
            get {
                return ResourceManager.GetString("BA2006_Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to built with {0} compiler version {1} (Front end version {2}).
        /// </summary>
        internal static string BA2006_Error_BadModule {
            get {
                return ResourceManager.GetString("BA2006_Error_BadModule", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is a managed assembly that was compiled with an outdated toolchain ({1}) that does not support security features (such as SHA256 PDB checksums and reproducible builds) that must be enabled by policy. To resolve this issue, compile with more recent tools ({2} or later)..
        /// </summary>
        internal static string BA2006_Error_OutdatedCsc {
            get {
                return ResourceManager.GetString("BA2006_Error_OutdatedCsc", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to All linked modules of &apos;{0}&apos; satisfy configured policy (observed compilers: {1})..
        /// </summary>
        internal static string BA2006_Pass {
            get {
                return ResourceManager.GetString("BA2006_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is a managed assembly that was compiled with toolchain ({1}) that supports all security features that must be enabled by policy..
        /// </summary>
        internal static string BA2006_Pass_Csc {
            get {
                return ResourceManager.GetString("BA2006_Pass_Csc", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Binaries should be compiled with a warning level that enables all critical security-relevant checks. Enabling at least warning level 3 enables important static analysis in the compiler that can identify bugs with a potential to provoke memory corruption, information disclosure, or double-free vulnerabilities. To resolve this issue, compile at warning level 3 or higher by supplying /W3, /W4, or /Wall to the compiler, and resolve the warnings emitted..
        /// </summary>
        internal static string BA2007_EnableCriticalCompilerWarnings_Description {
            get {
                return ResourceManager.GetString("BA2007_EnableCriticalCompilerWarnings_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; was compiled at too low a warning level (effective warning level {1} for one or more modules). Warning level 3 enables important static analysis in the compiler to flag bugs that can lead to memory corruption, information disclosure, or double-free vulnerabilities. To resolve this issue, compile at warning level 3 or higher by supplying /W3, /W4, or /Wall to the compiler, and resolve the warnings emitted. An example compiler command line triggering this check: {2}
        ///Modules triggering this check: {3}.
        /// </summary>
        internal static string BA2007_Error_InsufficientWarningLevel {
            get {
                return ResourceManager.GetString("BA2007_Error_InsufficientWarningLevel", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; contains code from an unknown language, preventing a comprehensive analysis of the compiler warning settings. The language could not be identified for the following modules: {1}.
        /// </summary>
        internal static string BA2007_Error_UnknownModuleLanguage {
            get {
                return ResourceManager.GetString("BA2007_Error_UnknownModuleLanguage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; disables compiler warning(s) which are required by policy. A compiler warning is typically required if it has a high likelihood of flagging memory corruption, information disclosure, or double-free vulnerabilities. To resolve this issue, enable the indicated warning(s) by removing /Wxxxx switches (where xxxx is a warning id indicated here) from your command line, and resolve any warnings subsequently raised during compilation. An example compiler command line triggering this check was: {1}
        ///Modules tr [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BA2007_Error_WarningsDisabled {
            get {
                return ResourceManager.GetString("BA2007_Error_WarningsDisabled", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; was compiled at a secure warning level ({1}) and does not include any modules that disable specific warnings that are required by policy. As a result, it is less likely that memory corruption, information disclosure, double-free and other security-related vulnerabilities exist in code..
        /// </summary>
        internal static string BA2007_Pass {
            get {
                return ResourceManager.GetString("BA2007_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Binaries should enable the compiler control guard feature (CFG) at build time to prevent attackers from redirecting execution to unexpected, unsafe locations. CFG analyzes and discovers all indirect-call instructions at compilation and link time. It also injects a check that precedes every indirect call in code that ensures the target is an expected, safe location.  If that check fails at runtime, the operating system will close the program..
        /// </summary>
        internal static string BA2008_EnableControlFlowGuard_Description {
            get {
                return ResourceManager.GetString("BA2008_EnableControlFlowGuard_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; does not enable the control flow guard (CFG) mitigation. To resolve this issue, pass /guard:cf on both the compiler and linker command lines. Binaries also require the /DYNAMICBASE linker option in order to enable CFG..
        /// </summary>
        internal static string BA2008_Error {
            get {
                return ResourceManager.GetString("BA2008_Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is a kernel mode portable executable compiled for a version of Windows that does not support the control flow guard feature for kernel mode binaries..
        /// </summary>
        internal static string BA2008_NotApplicable_UnsupportedKernelModeVersion {
            get {
                return ResourceManager.GetString("BA2008_NotApplicable_UnsupportedKernelModeVersion", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; enables the control flow guard mitigation. As a result, the operating system will force an application to close if an attacker is able to redirect execution in the component to an unexpected location..
        /// </summary>
        internal static string BA2008_Pass {
            get {
                return ResourceManager.GetString("BA2008_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Binaries should linked as DYNAMICBASE to be eligible for relocation by Address Space Layout Randomization (ASLR). ASLR is an important mitigation that makes it more difficult for an attacker to exploit memory corruption vulnerabilities. Configure your tools to build with this feature enabled. For C and C++ binaries, add /DYNAMICBASE to your linker command line. For .NET applications, use a compiler shipping with Visual Studio 2008 or later..
        /// </summary>
        internal static string BA2009_EnableAddressSpaceLayoutRandomization_Description {
            get {
                return ResourceManager.GetString("BA2009_EnableAddressSpaceLayoutRandomization_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is not marked as DYNAMICBASE. This means that the binary is not eligible for relocation by Address Space Layout Randomization (ASLR). ASLR is an important mitigation that makes it more difficult for an attacker to exploit memory corruption vulnerabilities. To resolve this issue, configure your tools to build with this feature enabled. For C and C++ binaries, add /DYNAMICBASE to your linker command line. For .NET applications, use a compiler shipping with Visual Studio 2008 or later..
        /// </summary>
        internal static string BA2009_Error_NotDynamicBase {
            get {
                return ResourceManager.GetString("BA2009_Error_NotDynamicBase", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is marked as DYNAMICBASE but relocation data has been stripped from the image, preventing address space layout randomization. .
        /// </summary>
        internal static string BA2009_Error_RelocsStripped {
            get {
                return ResourceManager.GetString("BA2009_Error_RelocsStripped", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is a Windows CE image but does not contain any relocation data, preventing Address Space Layout Randomization..
        /// </summary>
        internal static string BA2009_Error_WinCENoRelocationSection {
            get {
                return ResourceManager.GetString("BA2009_Error_WinCENoRelocationSection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is properly compiled to enable Address Space Layout Randomization, reducing an attacker&apos;s ability to exploit code in well-known locations..
        /// </summary>
        internal static string BA2009_Pass {
            get {
                return ResourceManager.GetString("BA2009_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to PE sections should not be marked as both writable and executable. This condition makes it easier for an attacker to exploit memory corruption vulnerabilities, as it may provide an attacker executable location(s) to inject shellcode. Because the loader will always mark the imports section as writable, it is therefore important to mark this section as non-executable. To resolve this issue, ensure that your program does not mark the imports section executable. Look for uses of /SECTION or /MERGE on the linker  [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BA2010_DoNotMarkImportsSectionAsExecutable_Description {
            get {
                return ResourceManager.GetString("BA2010_DoNotMarkImportsSectionAsExecutable_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; has the imports section marked executable. Because the loader will always mark the imports section as writable, it is important to mark this section as non-executable, so that an attacker cannot place shellcode here. To resolve this issue, ensure that your program does not mark the imports section as executable. Look for uses of /SECTION or /MERGE on the linker command line, or #pragma segment in source code, which change the imports section to be executable, or which merge the &quot;.rdata&quot; segment into a [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BA2010_Error {
            get {
                return ResourceManager.GetString("BA2010_Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; does not have an imports section that is marked as executable, helping to prevent the exploitation of code vulnerabilities..
        /// </summary>
        internal static string BA2010_Pass {
            get {
                return ResourceManager.GetString("BA2010_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Binaries should be built with the stack protector buffer security feature (/GS) enabled to increase the difficulty of exploiting stack buffer overflow memory corruption vulnerabilities. To resolve this issue, ensure that all modules compiled into the binary are compiled with the stack protector enabled by supplying /GS on the Visual C++ compiler command line..
        /// </summary>
        internal static string BA2011_EnableStackProtection_Description {
            get {
                return ResourceManager.GetString("BA2011_EnableStackProtection_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is a C or C++ binary built with the stack protector buffer security feature disabled in one or more modules. The stack protector (/GS) is a security feature of the compiler which makes it more difficult to exploit stack buffer overflow memory corruption vulnerabilities. To resolve this issue, ensure that your code is compiled with the stack protector enabled by supplying /GS on the Visual C++ compiler command line. The affected modules were: {1}.
        /// </summary>
        internal static string BA2011_Error {
            get {
                return ResourceManager.GetString("BA2011_Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; contains code from an unknown language, preventing a comprehensive analysis of the stack protector buffer security features. The language could not be identified for the following modules: {1}..
        /// </summary>
        internal static string BA2011_Error_UnknownModuleLanguage {
            get {
                return ResourceManager.GetString("BA2011_Error_UnknownModuleLanguage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is a C or C++ binary built with the stack protector buffer security feature enabled for all modules, making it more difficult for an attacker to exploit stack buffer overflow memory corruption vulnerabilities. .
        /// </summary>
        internal static string BA2011_Pass {
            get {
                return ResourceManager.GetString("BA2011_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Application code should not interfere with the stack protector. The stack protector (/GS) is a security feature of the compiler which makes it more difficult to exploit stack buffer overflow memory corruption vulnerabilities. The stack protector relies on a random number, called the &quot;security cookie&quot;, to detect these buffer overflows. This &apos;cookie&apos; is statically linked with your binary from a Visual C++ library in the form of the symbol __security_cookie. On recent Windows versions, the loader looks for the [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BA2012_DoNotModifyStackProtectionCookie_Description {
            get {
                return ResourceManager.GetString("BA2012_DoNotModifyStackProtectionCookie_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is a C or C++ binary that interferes with the stack protector. The stack protector (/GS) is a security feature of the compiler which makes it more difficult to exploit stack buffer overflow memory corruption vulnerabilities. The stack protector relies on a random number, called the &quot;security cookie&quot;, to detect these buffer overflows. This &apos;cookie&apos; is statically linked with your binary from a Visual C++ library in the form of the symbol __security_cookie. On recent Windows versions, the loader looks fo [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BA2012_Error {
            get {
                return ResourceManager.GetString("BA2012_Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is a C or C++binary that enables the stack protection feature but the security cookie could not be located. The binary may be corrupted..
        /// </summary>
        internal static string BA2012_Error_CouldNotLocateCookie {
            get {
                return ResourceManager.GetString("BA2012_Error_CouldNotLocateCookie", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is a C or C++ binary built with the buffer security feature that properly preserves the stack protecter cookie. This has the effect of enabling a significant increase in entropy provided by the operating system over that produced by the C runtime start-up code..
        /// </summary>
        internal static string BA2012_Pass {
            get {
                return ResourceManager.GetString("BA2012_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is  C or C++binary that does not contain a load config table, which indicates either that it was compiled and linked with a version of the compiler that precedes stack protection features or is a binary (such as an ngen&apos;ed assembly) that is not subject to relevant security issues..
        /// </summary>
        internal static string BA2012_Pass_NoLoadConfig {
            get {
                return ResourceManager.GetString("BA2012_Pass_NoLoadConfig", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; appears to be a packed C or C++ binary that reports a security cookie offset that exceeds the size of the packed file. Use of the stack protector (/GS) feature therefore could not be verified. The file was possibly packed by: {1}..
        /// </summary>
        internal static string BA2012_Warning_InvalidSecurityCookieOffset {
            get {
                return ResourceManager.GetString("BA2012_Warning_InvalidSecurityCookieOffset", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; appears to be a packed C or C++ binary that reports a security cookie offset that exceeds the size of the packed file. Use of the stack protector (/GS) feature therefore could not be verified. The file was possibly packed by: {1}..
        /// </summary>
        internal static string BA2012_Warning_InvalidSecurityCookieOffsetForPackedImage {
            get {
                return ResourceManager.GetString("BA2012_Warning_InvalidSecurityCookieOffsetForPackedImage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is a C or C++ binary that does not initialize the stack protector. The stack protector (/GS) is a security feature of the compiler which makes it more difficult to exploit stack buffer overflow memory corruption vulnerabilities. The stack protector requires access to entropy in order to be effective, which means a binary must initialize a random number generator at startup, by calling __security_init_cookie() as close to the binary&apos;s entry point as possible. Failing to do so will result in spurious bu [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BA2013_Error {
            get {
                return ResourceManager.GetString("BA2013_Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Binaries should properly initialize the stack protector (/GS) in order to increase the difficulty of exploiting stack buffer overflow memory corruption vulnerabilities. The stack protector requires access to entropy in order to be effective, which means a binary must initialize a random number generator at startup, by calling __security_init_cookie() as close to the binary&apos;s entry point as possible. Failing to do so will result in spurious buffer overflow detections on the part of the stack protector. To re [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BA2013_InitializeStackProtection_Description {
            get {
                return ResourceManager.GetString("BA2013_InitializeStackProtection_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is a C or C++ binary that does not enable the stack protection buffer security feature. It is therefore not required to initialize the stack protector..
        /// </summary>
        internal static string BA2013_NotApplicable_FeatureNotEnabled {
            get {
                return ResourceManager.GetString("BA2013_NotApplicable_FeatureNotEnabled", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is a C or C++ binary built with the buffer security feature that properly initializes the stack protecter. This has the effect of increasing the effectiveness of the feature and reducing spurious detections..
        /// </summary>
        internal static string BA2013_Pass {
            get {
                return ResourceManager.GetString("BA2013_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is a C or C++ binary that is not required to initialize the stack protection, as it does not contain executable code..
        /// </summary>
        internal static string BA2013_Pass_NoCode {
            get {
                return ResourceManager.GetString("BA2013_Pass_NoCode", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Application code should not disable stack protection for individual functions. The stack protector (/GS) is a security feature of the Windows native compiler which makes it more difficult to exploit stack buffer overflow memory corruption vulnerabilities. Disabling the stack protector, even on a function-by-function basis, can compromise the security of code. To resolve this issue, remove occurrences of __declspec(safebuffers) from your code. If the additional code inserted by the stack protector has been s [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BA2014_DoNotDisableStackProtectionForFunctions_Description {
            get {
                return ResourceManager.GetString("BA2014_DoNotDisableStackProtectionForFunctions_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is a C or C++ binary built with function(s) ({1}) that disable the stack protector. The stack protector (/GS) is a security feature of the compiler which makes it more difficult to exploit stack buffer overflow memory corruption vulnerabilities. Disabling the stack protector, even on a function-by-function basis, is disallowed by SDL policy. To resolve this issue, remove occurrences of __declspec(safebuffers) from your code. If the additional code inserted by the stack protector has been shown in prof [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BA2014_Error {
            get {
                return ResourceManager.GetString("BA2014_Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is a C or C++ binary built with the stack protector buffer security feature enabled which does not disable protection for any individual functions (via __declspec(safebuffers), making it more difficult for an attacker to exploit stack buffer overflow memory corruption vulnerabilities..
        /// </summary>
        internal static string BA2014_Pass {
            get {
                return ResourceManager.GetString("BA2014_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Binaries should be marked as high entropy Address Space Layout Randomization (ASLR) compatible. High entropy allows ASLR to be more effective in mitigating memory corruption vulnerabilities. To resolve this issue, configure your tool chain to mark the program high entropy compatible; e.g. by supplying /HIGHENTROPYVA to the C or C++ linker command line. Binaries must also be compiled as /LARGEADDRESSAWARE in order to enable high entropy ASLR..
        /// </summary>
        internal static string BA2015_EnableHighEntropyVirtualAddresses_Description {
            get {
                return ResourceManager.GetString("BA2015_EnableHighEntropyVirtualAddresses_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; does not declare itself as high entropy ASLR compatible. High entropy makes Address Space Layout Randomization more effective in mitigating memory corruption vulnerabilities. To resolve this issue, configure your tools to mark the program high entropy compatible; e.g. by supplying /HIGHENTROPYVA as well as /LARGEADDRESSAWARE to the C or C++ linker command line..
        /// </summary>
        internal static string BA2015_Error_NeitherHighEntropyVANorLargeAddressAware {
            get {
                return ResourceManager.GetString("BA2015_Error_NeitherHighEntropyVANorLargeAddressAware", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; does not declare itself as high entropy ASLR compatible. High entropy makes Address Space Layout Randomization more effective in mitigating memory corruption vulnerabilities. To resolve this issue, configure your tools to mark the program high entropy compatible; e.g. by supplying /HIGHENTROPYVA to the C or C++ linker command line. (This image was determined to have been properly compiled as /LARGEADDRESSAWARE.).
        /// </summary>
        internal static string BA2015_Error_NoHighEntropyVA {
            get {
                return ResourceManager.GetString("BA2015_Error_NoHighEntropyVA", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; does not declare itself as high entropy ASLR compatible. High entropy makes Address Space Layout Randomization more effective in mitigating memory corruption vulnerabilities. To resolve this issue, configure your tools to mark the program high entropy compatible by supplying /LARGEADDRESSAWARE to the C or C++ linker command line. (This image was determined to have been properly compiled as /HIGHENTROPYVA.).
        /// </summary>
        internal static string BA2015_Error_NoLargeAddressAware {
            get {
                return ResourceManager.GetString("BA2015_Error_NoLargeAddressAware", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is high entropy ASLR compatible, reducing an attacker&apos;s ability to exploit code in well-known locations..
        /// </summary>
        internal static string BA2015_Pass {
            get {
                return ResourceManager.GetString("BA2015_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is not marked NX compatible. The NXCompat bit, also known as &quot;Data Execution Prevention&quot; (DEP) or &quot;Execute Disable&quot; (XD), is a processor feature that allows a program to mark a piece of memory as non-executable. This helps mitigate memory corruption vulnerabilities by preventing an attacker from supplying direct shellcode in their exploit, because the exploit comes in the form of input data to the exploited program on a data segment, rather than on an executable code segment. To resolve this issue, en [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BA2016_Error {
            get {
                return ResourceManager.GetString("BA2016_Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Binaries should be marked as NX compatible to help prevent execution of untrusted data as code. The NXCompat bit, also known as &quot;Data Execution Prevention&quot; (DEP) or &quot;Execute Disable&quot; (XD), triggers a processor security feature that allows a program to mark a piece of memory as non-executable. This helps mitigate memory corruption vulnerabilities by preventing an attacker from supplying direct shellcode in their exploit (because the exploit comes in the form of input data to the exploited program on a data s [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BA2016_MarkImageAsNXCompatible_Description {
            get {
                return ResourceManager.GetString("BA2016_MarkImageAsNXCompatible_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is marked as NX compatible, helping to prevent attackers from executing code that is injected into data segments..
        /// </summary>
        internal static string BA2016_Pass {
            get {
                return ResourceManager.GetString("BA2016_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to X86 binaries should enable the SafeSEH mitigation to minimize exploitable memory corruption issues. SafeSEH makes it more difficult to exploit vulnerabilities that permit overwriting SEH control blocks on the stack, by verifying that the location to which a thrown SEH exception would jump is indeed defined as an exception handler in the source program (and not shellcode). To resolve this issue, supply the /SafeSEH flag on the linker command line. Note that you will need to configure your build system to sup [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BA2018_EnableSafeSEH_Description {
            get {
                return ResourceManager.GetString("BA2018_EnableSafeSEH_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is an x86 binary which {1}, indicating that it does not enable the SafeSEH mitigation. SafeSEH makes it more difficult to exploit memory corruption vulnerabilities that can overwrite SEH control blocks on the stack, by verifying that the location to which a thrown SEH exception would jump is indeed defined as an exception handler in the source program (and not shellcode). To resolve this issue, supply the /SafeSEH flag on the linker command line. Note that you will need to configure your build system  [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BA2018_Error {
            get {
                return ResourceManager.GetString("BA2018_Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to has an empty SE handler table in the load configuration table.
        /// </summary>
        internal static string BA2018_Error_EmptySEHandlerTable {
            get {
                return ResourceManager.GetString("BA2018_Error_EmptySEHandlerTable", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to contains an unexpectedly small load configuration table {size 0}.
        /// </summary>
        internal static string BA2018_Error_LoadConfigurationIsTooSmall {
            get {
                return ResourceManager.GetString("BA2018_Error_LoadConfigurationIsTooSmall", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to does not contain a load configuration table.
        /// </summary>
        internal static string BA2018_Error_NoLoadConfigurationTable {
            get {
                return ResourceManager.GetString("BA2018_Error_NoLoadConfigurationTable", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to has zero SE handlers in the load configuration table.
        /// </summary>
        internal static string BA2018_Error_NoSEHandlers {
            get {
                return ResourceManager.GetString("BA2018_Error_NoSEHandlers", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is an x86 binary that enables SafeSEH, a mitigation that verifies SEH exception jump targets are defined as exception handlers in the program (and not shellcode)..
        /// </summary>
        internal static string BA2018_Pass {
            get {
                return ResourceManager.GetString("BA2018_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is an x86 binary that does not use SEH, making it an invalid target for exploits that attempt to replace SEH jump targets with attacker-controlled shellcode..
        /// </summary>
        internal static string BA2018_Pass_NoSEH {
            get {
                return ResourceManager.GetString("BA2018_Pass_NoSEH", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Code or data sections should not be marked as both shared and writable. Because these sections are shared across processes, this condition might permit a process with low privilege to alter memory in a higher privilege process. If you do not actually require that a section be both writable and shared, remove one or both of these attributes (by modifying your .DEF file, the appropriate linker /section switch arguments, etc.). If you must share common data across processes (for inter-process communication (IP [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BA2019_DoNotMarkWritableSectionsAsShared_Description {
            get {
                return ResourceManager.GetString("BA2019_DoNotMarkWritableSectionsAsShared_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; contains one or more code or data sections ({1}) which are marked as both shared and writable. Because these sections are shared across processes, this condition might permit a process with low privilege to alter memory in a higher privilege process. If you do not actually require that a section be both writable and shared, remove one or both of these attributes (by modifying your .DEF file, the appropriate linker /section switch arguments, etc.). If you must share common data across processes (for in [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BA2019_Error {
            get {
                return ResourceManager.GetString("BA2019_Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; contains no data or code sections marked as both shared and writable, helping to prevent the exploitation of code vulnerabilities..
        /// </summary>
        internal static string BA2019_Pass {
            get {
                return ResourceManager.GetString("BA2019_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to PE sections should not be marked as both writable and executable. This condition makes it easier for an attacker to exploit memory corruption vulnerabilities, as it may provide an attacker executable location(s) to inject shellcode. To resolve this issue, configure your tools to not emit memory sections that are writable and executable. For example, look for uses of /SECTION on the linker command line for C and C++ programs, or #pragma section in C and C++ source code, which mark a section with both attribu [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BA2021_DoNotMarkWritableSectionsAsExecutable_Description {
            get {
                return ResourceManager.GetString("BA2021_DoNotMarkWritableSectionsAsExecutable_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; contains PE section(s) ({1}) that are both writable and executable. Writable and executable memory segments make it easier for an attacker to exploit memory corruption vulnerabilities, because it may provide an attacker executable location(s) to inject shellcode. To resolve this issue, configure your tools to not emit memory sections that are writable and executable. For example, look for uses of /SECTION on the linker command line for C and C++ programs, or #pragma section in C and C++ source code, w [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BA2021_Error {
            get {
                return ResourceManager.GetString("BA2021_Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; has a section alignment ({1}) that is smaller than its page size ({2})..
        /// </summary>
        internal static string BA2021_Error_UnexpectedSectionAligment {
            get {
                return ResourceManager.GetString("BA2021_Error_UnexpectedSectionAligment", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; contains no data or code sections marked as both shared and executable, helping to prevent the exploitation of code vulnerabilities..
        /// </summary>
        internal static string BA2021_Pass {
            get {
                return ResourceManager.GetString("BA2021_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; was signed exclusively with algorithms that WinTrustVerify has flagged as insecure. {1}.
        /// </summary>
        internal static string BA2022_Error_BadSigningAlgorithm {
            get {
                return ResourceManager.GetString("BA2022_Error_BadSigningAlgorithm", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; signing was flagged as insecure by WinTrustVerify with error code &apos;{1}&apos; ({2}).
        /// </summary>
        internal static string BA2022_Error_DidNotVerify {
            get {
                return ResourceManager.GetString("BA2022_Error_DidNotVerify", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; signing could not be completely verified because &apos;{1}&apos; failed with error code: &apos;{2}&apos;..
        /// </summary>
        internal static string BA2022_Error_WinTrustVerifyApiError {
            get {
                return ResourceManager.GetString("BA2022_Error_WinTrustVerifyApiError", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; appears to be signed with secure cryptographic algorithms. WinTrustVerify successfully validated the binary but did not attempt to validate certificate chaining or that the root certificate is trusted. The following digitial signature algorithms were detected: {1}.
        /// </summary>
        internal static string BA2022_Pass {
            get {
                return ResourceManager.GetString("BA2022_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Images should be correctly signed by trusted publishers using cryptographically secure signature algorithms. This rule invokes WinTrustVerify to validate that binary hash, signing and public key algorithms are secure and, where configurable, that key sizes meet acceptable size thresholds..
        /// </summary>
        internal static string BA2022_SignCorrectly_Description {
            get {
                return ResourceManager.GetString("BA2022_SignCorrectly_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Application code should be compiled with the Spectre mitigations switch (/Qspectre cl.exe command-line argument or &lt;SpectreMitigation&gt;Spectre&lt;/SpectreMitigation&gt; build property). Spectre attacks can compromise hardware-based isolation, allowing non-privileged users to retrieve potentially sensitive data from the CPU cache. To resolve this issue, provide the /Qspectre switch on the compiler command-line (or specify &lt;SpectreMitigation&gt;Spectre&lt;/SpectreMitigation&gt; in build properties), or pass /d2guardspecload  [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BA2024_EnableSpectreMitigations_Description {
            get {
                return ResourceManager.GetString("BA2024_EnableSpectreMitigations_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The MitigatedCompilers configuration entry was incorrect, either because version numbers overlapped or because a starting version number was higher than an ending version number..
        /// </summary>
        internal static string BA2024_InitializationException {
            get {
                return ResourceManager.GetString("BA2024_InitializationException", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to All linked modules &apos;{0}&apos; were compiled with mitigations enabled that help prevent Spectre (speculative execution side-channel attack) vulnerabilities..
        /// </summary>
        internal static string BA2024_Pass {
            get {
                return ResourceManager.GetString("BA2024_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; was compiled with one or more modules that do not enable code generation mitigations for speculative execution side-channel attack (Spectre) vulnerabilities. Spectre attacks can compromise hardware-based isolation, allowing non-privileged users to retrieve potentially sensitive data from the CPU cache. To resolve the issue, provide the /Qspectre switch on the compiler command-line (or specify &lt;SpectreMitigation&gt;Spectre&lt;/SpectreMitigation&gt; in build properties), or pass /d2guardspecload in cases where y [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BA2024_Warning {
            get {
                return ResourceManager.GetString("BA2024_Warning", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The following modules were compiled with a toolset that supports /Qspectre but the deprecated /d2guardspecload argument was specified on the command-line instead: {0}.
        /// </summary>
        internal static string BA2024_Warning_DeprecatedMitigationEnabled {
            get {
                return ResourceManager.GetString("BA2024_Warning_DeprecatedMitigationEnabled", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The following MASM modules were detected. The MASM compiler does not currently mitigate against speculative execution attacks:
        ///{0}.
        /// </summary>
        internal static string BA2024_Warning_MasmModulesDetected {
            get {
                return ResourceManager.GetString("BA2024_Warning_MasmModulesDetected", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The following modules were compiled with optimizations disabled (/Od), a condition that disables Spectre mitigations:
        ///{0}.
        /// </summary>
        internal static string BA2024_Warning_OptimizationsDisabled {
            get {
                return ResourceManager.GetString("BA2024_Warning_OptimizationsDisabled", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The following modules were compiled with Spectre mitigations explicitly disabled:
        ///{0}.
        /// </summary>
        internal static string BA2024_Warning_SpectreMitigationExplicitlyDisabled {
            get {
                return ResourceManager.GetString("BA2024_Warning_SpectreMitigationExplicitlyDisabled", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The following modules were compiled with a toolset that supports /Qspectre but the switch was not enabled on the command-line:
        ///{0}.
        /// </summary>
        internal static string BA2024_Warning_SpectreMitigationNotEnabled {
            get {
                return ResourceManager.GetString("BA2024_Warning_SpectreMitigationNotEnabled", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Control-flow Enforcement Technology (CET) Shadow Stack is a computer processor feature that provides capabilities to defend against return-oriented programming (ROP) based malware attacks..
        /// </summary>
        internal static string BA2025_EnableShadowStack_Description {
            get {
                return ResourceManager.GetString("BA2025_EnableShadowStack_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; enables the Control-flow Enforcement Technology (CET) Shadow Stack mitigation..
        /// </summary>
        internal static string BA2025_Pass {
            get {
                return ResourceManager.GetString("BA2025_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; does not enable the Control-flow Enforcement Technology (CET) Shadow Stack mitigation. To resolve this issue, pass /CETCOMPAT on the linker command lines..
        /// </summary>
        internal static string BA2025_Warning {
            get {
                return ResourceManager.GetString("BA2025_Warning", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to /sdl enables a superset of the baseline security checks provided by /GS and overrides /GS-. By default, /sdl is off. /sdl- disables the additional security checks..
        /// </summary>
        internal static string BA2026_EnableAdditionalSecurityChecks_Description {
            get {
                return ResourceManager.GetString("BA2026_EnableAdditionalSecurityChecks_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is a Windows PE that wasn&apos;t compiled with a compiler that provides the Microsoft /sdl command-line setting to enable additional compile-time and runtime security checks..
        /// </summary>
        internal static string BA2026_NotApplicable {
            get {
                return ResourceManager.GetString("BA2026_NotApplicable", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is a Windows PE that was compiled with recommended Security Development Lifecycle (SDL) checks. These checks change security-relevant warnings into errors, and set additional secure code-generation features..
        /// </summary>
        internal static string BA2026_Pass {
            get {
                return ResourceManager.GetString("BA2026_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is a Windows PE that wasn&apos;t compiled with recommended Security Development Lifecycle (SDL) checks. As a result some critical compile-time and runtime checks may be disabled, increasing the possibility of an exploitable runtime issue. To resolve this problem, pass &apos;/sdl&apos; on the cl.exe command-line, set the &apos;SDL checks&apos; property in the &apos;C/C++ -&gt; General&apos; Configuration property page, or explicitly set the &apos;SDLCheck&apos; property in the project file (nested within a &apos;CLCompile&apos; element) to &apos;true&apos;..
        /// </summary>
        internal static string BA2026_Warning {
            get {
                return ResourceManager.GetString("BA2026_Warning", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to SourceLink information should be present in the PDB. This applies to binaries built with the C# and MSVC compilers. When enabled, SourceLink information is added to the PDB. That information includes the repository URLs and commit IDs for all source files fed to the compiler. The PDB should also be uploaded to a symbol server so that it can be discovered by a debugger such as Visual Studio. Developers can then step into the matching source code. Frictionless source-driven debugging provides a good user expe [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BA2027_EnableSourceLink_Description {
            get {
                return ResourceManager.GetString("BA2027_EnableSourceLink_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The PDB for &apos;{0}&apos; contains SourceLink information, maximizing engineering and security response efficiency when source code is required for debugging and other critical analysis..
        /// </summary>
        internal static string BA2027_Pass {
            get {
                return ResourceManager.GetString("BA2027_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The PDB for &apos;{0}&apos; does not contain SourceLink information, compromising frictionless source-driven debugging and increasing latency of security response. Enable SourceLink by configuring necessary project properties and adding a package reference for your source control provider. See https://aka.ms/sourcelink for more information..
        /// </summary>
        internal static string BA2027_Warning {
            get {
                return ResourceManager.GetString("BA2027_Warning", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A Position Independent Executable (PIE) relocates all of its sections at load time, including the code section, if ASLR is enabled in the Linux kernel (instead of just the stack/heap). This makes ROP-style attacks more difficult. This can be enabled by passing &apos;-f pie&apos; to clang/gcc..
        /// </summary>
        internal static string BA3001_EnablePositionIndependentExecutable_Description {
            get {
                return ResourceManager.GetString("BA3001_EnablePositionIndependentExecutable_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to PIE disabled on executable &apos;{0}&apos;.  This means the code section will always be loaded to the same address, even if ASLR is enabled in the Linux kernel.  To address this, ensure you are compiling with &apos;-fpie&apos; when using clang/gcc..
        /// </summary>
        internal static string BA3001_Error {
            get {
                return ResourceManager.GetString("BA3001_Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to PIE enabled on executable &apos;{0}&apos;..
        /// </summary>
        internal static string BA3001_Pass_Executable {
            get {
                return ResourceManager.GetString("BA3001_Pass_Executable", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is a shared object library rather than an executable, and is automatically position independent..
        /// </summary>
        internal static string BA3001_Pass_Library {
            get {
                return ResourceManager.GetString("BA3001_Pass_Library", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This checks if a binary has an executable stack; an executable stack allows attackers to redirect code flow into stack memory, which is an easy place for an attacker to store shellcode. Ensure you are compiling with &apos;-z noexecstack&apos; to mark the stack as non-executable..
        /// </summary>
        internal static string BA3002_DoNotMarkStackAsExecutable_Description {
            get {
                return ResourceManager.GetString("BA3002_DoNotMarkStackAsExecutable_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GNU_STACK segment on &apos;{0}&apos; is missing, which means the stack will likely be loaded as executable.  Ensure you are using an up to date compiler and passing &apos;-z noexecstack&apos; to the compiler..
        /// </summary>
        internal static string BA3002_Error_NoStackSeg {
            get {
                return ResourceManager.GetString("BA3002_Error_NoStackSeg", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Stack on &apos;{0}&apos; is executable, which means that an attacker could use it as a place to store attack shellcode.  Ensure you are compiling with &apos;-z noexecstack&apos; to mark the stack as non-executable..
        /// </summary>
        internal static string BA3002_Error_StackExec {
            get {
                return ResourceManager.GetString("BA3002_Error_StackExec", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GNU_STACK segment marked as non-executable on &apos;{0}&apos;..
        /// </summary>
        internal static string BA3002_Pass {
            get {
                return ResourceManager.GetString("BA3002_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The stack protector ensures that all functions that use buffers over a certain size will use a stack cookie (and check it) to prevent stack based buffer overflows, exiting if stack smashing is detected. Use &apos;--fstack-protector-strong&apos; (all buffers of 4 bytes or more) or &apos;--fstack-protector-all&apos; (all functions) to enable this..
        /// </summary>
        internal static string BA3003_EnableStackProtector_Description {
            get {
                return ResourceManager.GetString("BA3003_EnableStackProtector_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The stack protector was not found in &apos;{0}&apos;. This may be because &apos;--stack-protector-strong&apos; was not used, or because it was explicitly disabled by &apos;-fno-stack-protectors&apos;.
        ///Modules did not meet the criteria: {1}.
        /// </summary>
        internal static string BA3003_Error {
            get {
                return ResourceManager.GetString("BA3003_Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Stack protector was found on &apos;{0}&apos;.  However, if you are not compiling with &apos;--stack-protector-strong&apos;, it may provide additional protections..
        /// </summary>
        internal static string BA3003_Pass {
            get {
                return ResourceManager.GetString("BA3003_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; is using debugging dwarf version &apos;{1}&apos;. The dwarf version 5 contains more information and should be used. To enable the debugging version 5 use &apos;-gdwarf-5&apos;..
        /// </summary>
        internal static string BA3004_Error {
            get {
                return ResourceManager.GetString("BA3004_Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This check ensures that debugging dwarf version used is 5. The dwarf version 5 contains more information and should be used. Use the compiler flags &apos;-gdwarf-5&apos; to enable this..
        /// </summary>
        internal static string BA3004_GenerateRequiredSymbolFormat_Description {
            get {
                return ResourceManager.GetString("BA3004_GenerateRequiredSymbolFormat_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The version of the debugging dwarf format is &apos;{0}&apos; for the file &apos;{1}&apos;.
        /// </summary>
        internal static string BA3004_Pass {
            get {
                return ResourceManager.GetString("BA3004_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This check ensures that stack clash protection is enabled. Each program running on a computer uses a special memory region called the stack. This memory region is special because it grows automatically when the program needs more stack memory. But if it grows too much and gets too close to another memory region, the program may confuse the stack with the other memory region. An attacker can exploit this confusion to overwrite the stack with the other memory region, or the other way around. Use the compiler  [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BA3005_EnableStackClashProtection_Description {
            get {
                return ResourceManager.GetString("BA3005_EnableStackClashProtection_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Stack Clash Protection is missing from this binary, so the stack from &apos;{0}&apos; can clash/colide with another memory region. Ensure you are compiling with the compiler flags &apos;-fstack-clash-protection&apos; to address this.
        ///Modules did not meet the criteria: {1}.
        /// </summary>
        internal static string BA3005_Error {
            get {
                return ResourceManager.GetString("BA3005_Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Stack Clash Protection was present, so &apos;{0}&apos; is protected..
        /// </summary>
        internal static string BA3005_Pass {
            get {
                return ResourceManager.GetString("BA3005_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This check ensures that non-executable stack is enabled. A common type of exploit is the stack buffer overflow. An application receives, from an attacker, more data than it is prepared for and stores this information on its stack, writing beyond the space reserved for it. This can be designed to cause execution of the data written on the stack. One mechanism to mitigate this vulnerability is for the system to not allow the execution of instructions in sections of memory identified as part of the stack. Use  [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string BA3006_EnableNonExecutableStack_Description {
            get {
                return ResourceManager.GetString("BA3006_EnableNonExecutableStack_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The non-executable stack is not enabled for this binary, so &apos;{0}&apos; can have a vulnerability of execution of the data written on the stack. Ensure you are compiling with the flag &apos;-z noexecstack&apos; to address this..
        /// </summary>
        internal static string BA3006_Error {
            get {
                return ResourceManager.GetString("BA3006_Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The non-executable stack flag was present, so &apos;{0}&apos; is protected..
        /// </summary>
        internal static string BA3006_Pass {
            get {
                return ResourceManager.GetString("BA3006_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This check ensures that some relocation data is marked as read only after the executable is loaded, and moved below the &apos;.data&apos; section in memory. This prevents them from being overwritten, which can redirect control flow. Use the compiler flags &apos;-Wl,-z,relro&apos; to enable this..
        /// </summary>
        internal static string BA3010_EnableReadOnlyRelocations_Description {
            get {
                return ResourceManager.GetString("BA3010_EnableReadOnlyRelocations_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The GNU_RELRO segment is missing from this binary, so relocation sections in &apos;{0}&apos; will not be marked as read only after the binary is loaded.  An attacker can overwrite these to redirect control flow.  Ensure you are compiling with the compiler flags &apos;-Wl,-z,relro&apos; to address this..
        /// </summary>
        internal static string BA3010_Error {
            get {
                return ResourceManager.GetString("BA3010_Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The GNU_RELRO segment was present, so &apos;{0}&apos; is protected..
        /// </summary>
        internal static string BA3010_Pass {
            get {
                return ResourceManager.GetString("BA3010_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This check ensures that some relocation data is marked as read only after the executable is loaded, and moved below the &apos;.data&apos; section in memory. This prevents them from being overwritten, which can redirect control flow. Use the compiler flags &apos;-Wl,-z,now&apos; to enable this..
        /// </summary>
        internal static string BA3011_EnableBindNow_Description {
            get {
                return ResourceManager.GetString("BA3011_EnableBindNow_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The BIND_NOW flag is missing from this binary, so relocation sections in &apos;{0}&apos; will not be marked as read only after the binary is loaded.  An attacker can overwrite these to redirect control flow.  Ensure you are compiling with the compiler flags &apos;-Wl,-z,now&apos; to address this..
        /// </summary>
        internal static string BA3011_Error {
            get {
                return ResourceManager.GetString("BA3011_Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The BIND_NOW flag was present, so &apos;{0}&apos; is protected..
        /// </summary>
        internal static string BA3011_Pass {
            get {
                return ResourceManager.GetString("BA3011_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to No checked functions are present/used when compiling &apos;{0}&apos;, and it was compiled with GCC--and it uses functions that can be checked. The Fortify Source flag replaces some unsafe functions with checked versions when a static length can be determined, and can be enabled by passing &apos;-D_FORTIFY_SOURCE=2&apos; when optimization level 2 (&apos;-O2&apos;) is enabled.  It is possible that the flag was passed, but that the compiler could not statically determine the length of any buffers/strings..
        /// </summary>
        internal static string BA3030_Error {
            get {
                return ResourceManager.GetString("BA3030_Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to All functions that can be checked in &apos;{0}&apos; are using the checked versions, so this binary is protected from overflows caused by those function&apos;s use..
        /// </summary>
        internal static string BA3030_Pass_AllFunctionsChecked {
            get {
                return ResourceManager.GetString("BA3030_Pass_AllFunctionsChecked", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to No unsafe functions which can be replaced with checked versions are used in &apos;{0}&apos;..
        /// </summary>
        internal static string BA3030_Pass_NoCheckableFunctions {
            get {
                return ResourceManager.GetString("BA3030_Pass_NoCheckableFunctions", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Some checked functions were found in &apos;{0}&apos;; however, there were also some unchecked functions, which can occur when the compiler cannot statically determine the length of a buffer/string.  We recommend reviewing your usage of functions like memcpy or strcpy..
        /// </summary>
        internal static string BA3030_Pass_SomeFunctionsChecked {
            get {
                return ResourceManager.GetString("BA3030_Pass_SomeFunctionsChecked", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GCC can automatically replace unsafe functions with checked variants when it can statically determine the length of a buffer or string. In the case of an overflow, the checked version will safely exit the program (rather than potentially allowing an exploit). This feature can be enabled by passing &apos;-D_FORTIFY_SOURCE=2&apos; when optimization level 2 is enabled (&apos;-O2&apos;)..
        /// </summary>
        internal static string BA3030_UseGccCheckedFunctions_Description {
            get {
                return ResourceManager.GetString("BA3030_UseGccCheckedFunctions_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The SafeStack instrumentation pass protects programs by implementing two separate program stacks, one for return addresses and local variables, and the other for everything else. To enable SafeStack, pass &apos;-fsanitize=safe-stack&apos; flag to both compile and link command lines..
        /// </summary>
        internal static string BA3031_EnableClangSafeStack_Description {
            get {
                return ResourceManager.GetString("BA3031_EnableClangSafeStack_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; was compiled using Clang but without the SafeStack instrumentation pass, which should be used to mitigate the risk of stack-based buffer overflows. To enable SafeStack, pass &apos;-fsanitize=safe-stack&apos; flag to both compile and link command lines..
        /// </summary>
        internal static string BA3031_Error {
            get {
                return ResourceManager.GetString("BA3031_Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; was compiled using Clang but without the SafeStack instrumentation pass, which should be used to mitigate the risk of stack-based buffer overflows. To enable SafeStack, pass &apos;-fsanitize=safe-stack&apos; flag to both compile and link command lines. You might need to update your version of Clang to enable it..
        /// </summary>
        internal static string BA3031_Error_ClangVersionMayNeedUpgrade {
            get {
                return ResourceManager.GetString("BA3031_Error_ClangVersionMayNeedUpgrade", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; was compiled using Clang and with the SafeStack instrumentation pass, which mitigates the risk of stack-based buffer overflows..
        /// </summary>
        internal static string BA3031_Pass {
            get {
                return ResourceManager.GetString("BA3031_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule emits CSV data to the console for every compiler/language/version combination that&apos;s observed in any PDB-linked compiland..
        /// </summary>
        internal static string BA4001_ReportPECompilerData_Description {
            get {
                return ResourceManager.GetString("BA4001_ReportPECompilerData_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule emits CSV data to the console for every compiler/language/version combination that&apos;s observed..
        /// </summary>
        internal static string BA4002_ReportELFCompilerData_Description {
            get {
                return ResourceManager.GetString("BA4002_ReportELFCompilerData_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A Position Independent Executable (PIE) relocates all of its sections at load time, including the code section, if ASLR is enabled in the Linux kernel (instead of just the stack/heap). This makes ROP-style attacks more difficult. This can be enabled by passing &apos;-f pie&apos; to clang/gcc..
        /// </summary>
        internal static string BA5001_EnablePositionIndependentExecutable_Description {
            get {
                return ResourceManager.GetString("BA5001_EnablePositionIndependentExecutable_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to PIE disabled on executable &apos;{0}&apos;.  This means the code section will always be loaded to the same address, even if ASLR is enabled in the Linux kernel.  To address this, ensure you are compiling with &apos;-fpie&apos; when using clang/gcc..
        /// </summary>
        internal static string BA5001_Error {
            get {
                return ResourceManager.GetString("BA5001_Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to PIE enabled on executable &apos;{0}&apos;..
        /// </summary>
        internal static string BA5001_Pass {
            get {
                return ResourceManager.GetString("BA5001_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This checks if a binary has an executable stack; an executable stack allows attackers to redirect code flow into stack memory, which is an easy place for an attacker to store shellcode. Ensure do not enable flag &quot;--allow_stack_execute&quot;..
        /// </summary>
        internal static string BA5002_DoNotAllowExecutableStack_Description {
            get {
                return ResourceManager.GetString("BA5002_DoNotAllowExecutableStack_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Stack on &apos;{0}&apos; is executable, which means that an attacker could use it as a place to store attack shellcode.  Ensure do not compile with flag &quot;--allow_stack_execute&quot; to mark the stack as non-executable..
        /// </summary>
        internal static string BA5002_Error {
            get {
                return ResourceManager.GetString("BA5002_Error", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Executable stack is not allowed on executable &apos;{0}&apos;..
        /// </summary>
        internal static string BA5002_Pass {
            get {
                return ResourceManager.GetString("BA5002_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Incremental linking support increases binary size and can reduce runtime performance. The support for incremental linking adds padding and other overhead to support the ability to modify a binary without a full link.  The use of incrementally linked binaries may reduce the level of determinism because previous compilations will have lingering effects on subsequent compilations.  Fully optimized release builds should not specify incremental linking..
        /// </summary>
        internal static string BA6001_DisableIncrementalLinkingInReleaseBuilds_Description {
            get {
                return ResourceManager.GetString("BA6001_DisableIncrementalLinkingInReleaseBuilds_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; was compiled with incremental linking disabled..
        /// </summary>
        internal static string BA6001_Pass {
            get {
                return ResourceManager.GetString("BA6001_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; appears to be compiled as release but enables incremental linking, increasing binary size and further compromising runtime performance by preventing enabling maximal code optimization..
        /// </summary>
        internal static string BA6001_Warning {
            get {
                return ResourceManager.GetString("BA6001_Warning", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The /GF compiler option, also known as Eliminate Duplicate Strings or String Pooling, will combine identical strings in a program to a single readonly copy. This can significantly reduce binary size for programs with many string resources..
        /// </summary>
        internal static string BA6002_EliminateDuplicateStrings_Description {
            get {
                return ResourceManager.GetString("BA6002_EliminateDuplicateStrings_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; was compiled with Eliminate Duplicate Strings (/GF) enabled..
        /// </summary>
        internal static string BA6002_Pass {
            get {
                return ResourceManager.GetString("BA6002_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; was compiled without Eliminate Duplicate Strings (/GF) enabled, increasing binary size.  The following modules do not specify that policy: {1}..
        /// </summary>
        internal static string BA6002_Warning {
            get {
                return ResourceManager.GetString("BA6002_Warning", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to COMDAT folding can significantly reduce binary size by combining functions which generate identical machine code into a single copy in the final binary..
        /// </summary>
        internal static string BA6004_EnableCOMDATFolding_Description {
            get {
                return ResourceManager.GetString("BA6004_EnableCOMDATFolding_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; was compiled with COMDAT folding (/OPT:ICF) enabled.
        /// </summary>
        internal static string BA6004_Pass {
            get {
                return ResourceManager.GetString("BA6004_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; was compiled with COMDAT folding (/OPT:ICF) disabled, increasing binary size..
        /// </summary>
        internal static string BA6004_Warning_DisabledForRelease {
            get {
                return ResourceManager.GetString("BA6004_Warning_DisabledForRelease", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; appears to be a Debug build which was compiled with COMDAT folding (/OPT:ICF) enabled. That may make debugging more difficult..
        /// </summary>
        internal static string BA6004_Warning_EnabledForDebug {
            get {
                return ResourceManager.GetString("BA6004_Warning_EnabledForDebug", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Optimize References can significantly reduce binary size because it instructs the linker to remove unreferenced functions and data from the final binary..
        /// </summary>
        internal static string BA6005_EnableOptimizeReferences_Description {
            get {
                return ResourceManager.GetString("BA6005_EnableOptimizeReferences_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; was compiled with Optimize References (/OPT:REF) enabled.
        /// </summary>
        internal static string BA6005_Pass {
            get {
                return ResourceManager.GetString("BA6005_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; was compiled with Optimize References (/OPT:REF) disabled, increasing binary size..
        /// </summary>
        internal static string BA6005_Warning {
            get {
                return ResourceManager.GetString("BA6005_Warning", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enabling Link Time Code Generation (LTCG) performs whole-program optimization, which is able to better optimize code across translation units. LTCG is also a prerequisite for Profile-Guided Optimization (PGO) which can further improve performance..
        /// </summary>
        internal static string BA6006_EnableLinkTimeCodeGeneration_Description {
            get {
                return ResourceManager.GetString("BA6006_EnableLinkTimeCodeGeneration_Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; was compiled with LinkTimeCodeGeneration (/LTCG) enabled..
        /// </summary>
        internal static string BA6006_Pass {
            get {
                return ResourceManager.GetString("BA6006_Pass", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; was compiled without Link Time Code Generation (/LTCG). Enabling LTCG can improve optimizations and performance..
        /// </summary>
        internal static string BA6006_Warning {
            get {
                return ResourceManager.GetString("BA6006_Warning", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; was not evaluated for check &apos;{1}&apos; because its PDB could not be loaded ({2})..
        /// </summary>
        internal static string ERR997_ExceptionLoadingPdb {
            get {
                return ResourceManager.GetString("ERR997_ExceptionLoadingPdb", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; was not evaluated because its PDB could not be loaded ({1})..
        /// </summary>
        internal static string ERR997_ExceptionLoadingPdbGeneric {
            get {
                return ResourceManager.GetString("ERR997_ExceptionLoadingPdbGeneric", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &apos;{0}&apos; was not evaluated for check &apos;{1}&apos; as the analysis is not relevant based on observed metadata: {2}..
        /// </summary>
        internal static string NotApplicable_InvalidMetadata {
            get {
                return ResourceManager.GetString("NotApplicable_InvalidMetadata", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This check is not supported on the &apos;{0}&apos; platform, as it requires interoperability with a native Windows library..
        /// </summary>
        internal static string NotApplicable_PlatformUnsupported {
            get {
                return ResourceManager.GetString("NotApplicable_PlatformUnsupported", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Could not locate the PDB for &apos;{0}&apos;. Probing details:
        ///{1}.
        /// </summary>
        internal static string PdbLoadFailed {
            get {
                return ResourceManager.GetString("PdbLoadFailed", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The PDB for &apos;{0}&apos; was found and loaded. Probing details:
        ///{1}.
        /// </summary>
        internal static string PdbLoadSucceeded {
            get {
                return ResourceManager.GetString("PdbLoadSucceeded", resourceCulture);
            }
        }
    }
}
