{
  "$schema": "https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0-rtm.6.json",
  "version": "2.1.0",
  "runs": [
    {
      "results": [
        {
          "ruleId": "BA2001",
          "ruleIndex": 0,
          "kind": "pass",
          "level": "none",
          "message": {
            "id": "Pass",
            "arguments": [
              "Native_x64_VS2019_SDL_Enabled.exe"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Test.FunctionalTests.BinSkim.Driver/BaselineTestData/Native_x64_VS2019_SDL_Enabled.exe"
                }
              }
            }
          ]
        },
        {
          "ruleId": "BA2002",
          "ruleIndex": 1,
          "kind": "pass",
          "level": "none",
          "message": {
            "id": "Pass",
            "arguments": [
              "Native_x64_VS2019_SDL_Enabled.exe"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Test.FunctionalTests.BinSkim.Driver/BaselineTestData/Native_x64_VS2019_SDL_Enabled.exe"
                }
              }
            }
          ]
        },
        {
          "ruleId": "BA2004",
          "ruleIndex": 2,
          "message": {
            "id": "Warning_NativeWithInsecureStaticLibraryCompilands",
            "arguments": [
              "Native_x64_VS2019_SDL_Enabled.exe",
              "Microsoft (R) Macro Assembler : masm : 14.29.30034.2 : MSVCRTD.lib [MD5] (amdsecgs.obj,guard_dispatch.obj,guard_xfg_dispatch.obj)\r\nMicrosoft (R) Optimizing Compiler : c : 19.29.30034.2 : MSVCRTD.lib [MD5] (cpu_disp.obj,debugger_jmc.obj,dyn_tls_dtor.obj,dyn_tls_init.obj,gs_cookie.obj,gs_report.obj,gs_support.obj,guard_support.obj,loadcfg.obj,matherr_detection.obj,ucrt_detection.obj)\r\nMicrosoft (R) Optimizing Compiler : cxx : 19.29.30034.2 : MSVCRTD.lib [MD5] (argv_mode.obj,commit_mode.obj,default_local_stdio_options.obj,denormal_control.obj,env_mode.obj,error.obj,exe_main.obj,file_mode.obj,gshandler.obj,gshandlereh4.obj,init.obj,initializers.obj,initsect.obj,invalid_parameter_handler.obj,matherr.obj,new_mode.obj,pdblkup.obj,stack.obj,thread_locale.obj,tncleanup.obj,ucrt_stubs.obj,userapi.obj,utility.obj,utility_desktop.obj)\r\n"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Test.FunctionalTests.BinSkim.Driver/BaselineTestData/Native_x64_VS2019_SDL_Enabled.exe"
                }
              }
            }
          ]
        },
        {
          "ruleId": "BA2004",
          "ruleIndex": 2,
          "level": "error",
          "message": {
            "id": "Error_NativeWithInsecureDirectCompilands",
            "arguments": [
              "Native_x64_VS2019_SDL_Enabled.exe",
              "Microsoft (R) Optimizing Compiler : cxx : 19.29.30038.1 : [directly linked] [MD5] (Native_x64_VS2019.obj)\r\n"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Test.FunctionalTests.BinSkim.Driver/BaselineTestData/Native_x64_VS2019_SDL_Enabled.exe"
                }
              }
            }
          ]
        },
        {
          "ruleId": "BA2005",
          "ruleIndex": 3,
          "kind": "pass",
          "level": "none",
          "message": {
            "id": "Pass",
            "arguments": [
              "Native_x64_VS2019_SDL_Enabled.exe"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Test.FunctionalTests.BinSkim.Driver/BaselineTestData/Native_x64_VS2019_SDL_Enabled.exe"
                }
              }
            }
          ]
        },
        {
          "ruleId": "BA2006",
          "ruleIndex": 4,
          "kind": "pass",
          "level": "none",
          "message": {
            "id": "Pass",
            "arguments": [
              "Native_x64_VS2019_SDL_Enabled.exe",
              "Microsoft (R) Optimizing Compiler:C:19.29.30034.2, Microsoft (R) Optimizing Compiler:Cxx:19.29.30034.2, Microsoft (R) Optimizing Compiler:Cxx:19.29.30038.1"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Test.FunctionalTests.BinSkim.Driver/BaselineTestData/Native_x64_VS2019_SDL_Enabled.exe"
                }
              }
            }
          ]
        },
        {
          "ruleId": "BA2007",
          "ruleIndex": 5,
          "kind": "pass",
          "level": "none",
          "message": {
            "id": "Pass",
            "arguments": [
              "Native_x64_VS2019_SDL_Enabled.exe",
              "3"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Test.FunctionalTests.BinSkim.Driver/BaselineTestData/Native_x64_VS2019_SDL_Enabled.exe"
                }
              }
            }
          ]
        },
        {
          "ruleId": "BA2008",
          "ruleIndex": 6,
          "kind": "pass",
          "level": "none",
          "message": {
            "id": "Pass",
            "arguments": [
              "Native_x64_VS2019_SDL_Enabled.exe"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Test.FunctionalTests.BinSkim.Driver/BaselineTestData/Native_x64_VS2019_SDL_Enabled.exe"
                }
              }
            }
          ]
        },
        {
          "ruleId": "BA2009",
          "ruleIndex": 7,
          "kind": "pass",
          "level": "none",
          "message": {
            "id": "Pass",
            "arguments": [
              "Native_x64_VS2019_SDL_Enabled.exe"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Test.FunctionalTests.BinSkim.Driver/BaselineTestData/Native_x64_VS2019_SDL_Enabled.exe"
                }
              }
            }
          ]
        },
        {
          "ruleId": "BA2010",
          "ruleIndex": 8,
          "kind": "pass",
          "level": "none",
          "message": {
            "id": "Pass",
            "arguments": [
              "Native_x64_VS2019_SDL_Enabled.exe"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Test.FunctionalTests.BinSkim.Driver/BaselineTestData/Native_x64_VS2019_SDL_Enabled.exe"
                }
              }
            }
          ]
        },
        {
          "ruleId": "BA2011",
          "ruleIndex": 9,
          "kind": "pass",
          "level": "none",
          "message": {
            "id": "Pass",
            "arguments": [
              "Native_x64_VS2019_SDL_Enabled.exe"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Test.FunctionalTests.BinSkim.Driver/BaselineTestData/Native_x64_VS2019_SDL_Enabled.exe"
                }
              }
            }
          ]
        },
        {
          "ruleId": "BA2012",
          "ruleIndex": 10,
          "kind": "pass",
          "level": "none",
          "message": {
            "id": "Pass",
            "arguments": [
              "Native_x64_VS2019_SDL_Enabled.exe"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Test.FunctionalTests.BinSkim.Driver/BaselineTestData/Native_x64_VS2019_SDL_Enabled.exe"
                }
              }
            }
          ]
        },
        {
          "ruleId": "BA2013",
          "ruleIndex": 11,
          "kind": "pass",
          "level": "none",
          "message": {
            "id": "Pass",
            "arguments": [
              "Native_x64_VS2019_SDL_Enabled.exe"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Test.FunctionalTests.BinSkim.Driver/BaselineTestData/Native_x64_VS2019_SDL_Enabled.exe"
                }
              }
            }
          ]
        },
        {
          "ruleId": "BA2014",
          "ruleIndex": 12,
          "kind": "pass",
          "level": "none",
          "message": {
            "id": "Pass",
            "arguments": [
              "Native_x64_VS2019_SDL_Enabled.exe"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Test.FunctionalTests.BinSkim.Driver/BaselineTestData/Native_x64_VS2019_SDL_Enabled.exe"
                }
              }
            }
          ]
        },
        {
          "ruleId": "BA2015",
          "ruleIndex": 13,
          "kind": "pass",
          "level": "none",
          "message": {
            "id": "Pass",
            "arguments": [
              "Native_x64_VS2019_SDL_Enabled.exe"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Test.FunctionalTests.BinSkim.Driver/BaselineTestData/Native_x64_VS2019_SDL_Enabled.exe"
                }
              }
            }
          ]
        },
        {
          "ruleId": "BA2019",
          "ruleIndex": 14,
          "kind": "pass",
          "level": "none",
          "message": {
            "id": "Pass",
            "arguments": [
              "Native_x64_VS2019_SDL_Enabled.exe"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Test.FunctionalTests.BinSkim.Driver/BaselineTestData/Native_x64_VS2019_SDL_Enabled.exe"
                }
              }
            }
          ]
        },
        {
          "ruleId": "BA2021",
          "ruleIndex": 15,
          "kind": "pass",
          "level": "none",
          "message": {
            "id": "Pass",
            "arguments": [
              "Native_x64_VS2019_SDL_Enabled.exe"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Test.FunctionalTests.BinSkim.Driver/BaselineTestData/Native_x64_VS2019_SDL_Enabled.exe"
                }
              }
            }
          ]
        },
        {
          "ruleId": "BA2024",
          "ruleIndex": 16,
          "kind": "pass",
          "level": "none",
          "message": {
            "id": "Pass",
            "arguments": [
              "Native_x64_VS2019_SDL_Enabled.exe"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Test.FunctionalTests.BinSkim.Driver/BaselineTestData/Native_x64_VS2019_SDL_Enabled.exe"
                }
              }
            }
          ]
        },
        {
          "ruleId": "BA2025",
          "ruleIndex": 17,
          "message": {
            "id": "Warning",
            "arguments": [
              "Native_x64_VS2019_SDL_Enabled.exe"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Test.FunctionalTests.BinSkim.Driver/BaselineTestData/Native_x64_VS2019_SDL_Enabled.exe"
                }
              }
            }
          ]
        },
        {
          "ruleId": "BA2026",
          "ruleIndex": 18,
          "kind": "pass",
          "level": "none",
          "message": {
            "id": "Pass",
            "arguments": [
              "Native_x64_VS2019_SDL_Enabled.exe"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Test.FunctionalTests.BinSkim.Driver/BaselineTestData/Native_x64_VS2019_SDL_Enabled.exe"
                }
              }
            }
          ]
        },
        {
          "ruleId": "BA2027",
          "ruleIndex": 19,
          "message": {
            "id": "Warning",
            "arguments": [
              "Native_x64_VS2019_SDL_Enabled.exe"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Test.FunctionalTests.BinSkim.Driver/BaselineTestData/Native_x64_VS2019_SDL_Enabled.exe"
                }
              }
            }
          ]
        },
        {
          "ruleId": "BA6002",
          "ruleIndex": 20,
          "message": {
            "id": "Warning",
            "arguments": [
              "Native_x64_VS2019_SDL_Enabled.exe",
              "Microsoft (R) Optimizing Compiler : cxx : 19.29.30038.1 : [directly linked] (Native_x64_VS2019.obj)\r\n"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Test.FunctionalTests.BinSkim.Driver/BaselineTestData/Native_x64_VS2019_SDL_Enabled.exe"
                }
              }
            }
          ]
        },
        {
          "ruleId": "BA6004",
          "ruleIndex": 21,
          "kind": "pass",
          "level": "none",
          "message": {
            "id": "Pass",
            "arguments": [
              "Native_x64_VS2019_SDL_Enabled.exe"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Test.FunctionalTests.BinSkim.Driver/BaselineTestData/Native_x64_VS2019_SDL_Enabled.exe"
                }
              }
            }
          ]
        },
        {
          "ruleId": "BA6005",
          "ruleIndex": 22,
          "message": {
            "id": "Warning",
            "arguments": [
              "Native_x64_VS2019_SDL_Enabled.exe"
            ]
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/Test.FunctionalTests.BinSkim.Driver/BaselineTestData/Native_x64_VS2019_SDL_Enabled.exe"
                }
              }
            }
          ]
        }
      ],
      "tool": {
        "driver": {
          "name": "BinSkim",
          "rules": [
            {
              "id": "BA2001",
              "name": "LoadImageAboveFourGigabyteAddress",
              "fullDescription": {
                "text": "64-bit images should have a preferred base address above the 4GB boundary to prevent triggering an Address Space Layout Randomization (ASLR) compatibility mode that decreases security. ASLR compatibility mode reduces the number of locations to which ASLR may relocate the binary, reducing its effectiveness at mitigating memory corruption vulnerabilities.\r\nTo resolve this issue, either use the default preferred base address by removing any uses of /baseaddress from compiler command lines, or /BASE from linker command lines (recommended), or configure your program to start at a base address above 4GB when compiled for 64 bit platforms (by changing the constant passed to /baseaddress or /BASE).\r\nNote that if you choose to continue using a custom preferred base address, you will need to make this modification only for 64-bit builds, as base addresses above 4GB are not valid for 32-bit binaries.\r\nFor VC projects make sure that ItemDefinitionGroup - Link - BaseAddress property is not set."
              },
              "help": {
                "text": "64-bit images should have a preferred base address above the 4GB boundary to prevent triggering an Address Space Layout Randomization (ASLR) compatibility mode that decreases security. ASLR compatibility mode reduces the number of locations to which ASLR may relocate the binary, reducing its effectiveness at mitigating memory corruption vulnerabilities.\r\nTo resolve this issue, either use the default preferred base address by removing any uses of /baseaddress from compiler command lines, or /BASE from linker command lines (recommended), or configure your program to start at a base address above 4GB when compiled for 64 bit platforms (by changing the constant passed to /baseaddress or /BASE).\r\nNote that if you choose to continue using a custom preferred base address, you will need to make this modification only for 64-bit builds, as base addresses above 4GB are not valid for 32-bit binaries.\r\nFor VC projects make sure that ItemDefinitionGroup - Link - BaseAddress property is not set."
              },
              "messageStrings": {
                "Pass": {
                  "text": "'{0}' is a 64-bit image with a base address that is >= 4 gigabytes, increasing the effectiveness of Address Space Layout Randomization (which helps prevent attackers from executing security-sensitive code in well-known locations)."
                },
                "Error": {
                  "text": "'{0}' is a 64-bit image with a preferred base address below the 4GB boundary. \r\nHaving a preferred base address below this boundary triggers a compatibility mode in Address Space Layout Randomization (ASLR) on recent versions of Windows that reduces the number of locations to which ASLR may relocate the binary. This reduces the effectiveness of ASLR at mitigating memory corruption vulnerabilities.\r\nTo resolve this issue, either use the default preferred base address by removing any uses of /baseaddress from compiler command lines, or /BASE from linker command lines (recommended), or configure your program to start at a base address above 4GB when compiled for 64 bit platforms (by changing the constant passed to /baseaddress or /BASE).\r\nNote that if you choose to continue using a custom preferred base address, you will need to make this modification only for 64-bit builds, as base addresses above 4GB are not valid for 32-bit binaries.\r\nFor VC projects make sure that ItemDefinitionGroup - Link - BaseAddress property is not set."
                },
                "NotApplicable_InvalidMetadata": {
                  "text": "'{0}' was not evaluated for check '{1}' as the analysis is not relevant based on observed metadata: {2}."
                }
              },
              "helpUri": "https://github.com/microsoft/binskim/blob/main/docs/BinSkimRules.md#rule-BA2001LoadImageAboveFourGigabyteAddress",
              "properties": {
                "equivalentBinScopeRuleReadableName": "FourGbCheck"
              }
            },
            {
              "id": "BA2002",
              "name": "DoNotIncorporateVulnerableDependencies",
              "fullDescription": {
                "text": "Binaries should not take dependencies on code with known security vulnerabilities."
              },
              "help": {
                "text": "Binaries should not take dependencies on code with known security vulnerabilities."
              },
              "messageStrings": {
                "Pass": {
                  "text": "'{0}' does not incorporate any known vulnerable dependencies, as configured by current policy."
                },
                "Error": {
                  "text": "'{0}' was built with a version of {1} which is subject to the following issues: {2}. To resolve this, {3}. The source files that triggered this were: {4}"
                },
                "NotApplicable_InvalidMetadata": {
                  "text": "'{0}' was not evaluated for check '{1}' as the analysis is not relevant based on observed metadata: {2}."
                }
              },
              "helpUri": "https://github.com/microsoft/binskim/blob/main/docs/BinSkimRules.md#rule-BA2002DoNotIncorporateVulnerableDependencies",
              "properties": {
                "equivalentBinScopeRuleReadableName": "ATLVersionCheck"
              }
            },
            {
              "id": "BA2004",
              "name": "EnableSecureSourceCodeHashing",
              "fullDescription": {
                "text": "Compilers can generate and store checksums of source files in order to provide linkage between binaries, their PDBs, and associated source code.\r\nThis information is typically used to resolve source file when debugging but it can also be used to verify that a specific body of source code is, in fact, the code that was used to produce a specific set of binaries and PDBs.\r\nThis validation is helpful in verifying supply chain integrity. Due to this security focus, it is important that the hashing algorithm used to produce checksums is secure.\r\nLegacy hashing algorithms, such as MD5 and SHA-1, have been demonstrated to be broken by modern hardware (that is, it is computationally feasible to force hash collisions, in which a common hash is generated from distinct files).\r\nUsing a secure hashing algorithm, such as SHA-256, prevents the possibility of collision attacks, in which the checksum of a malicious file is used to produce a hash that satisfies the system that it is, in fact, the original file processed by the compiler.\r\nFor managed binaries, pass '-checksumalgorithm:SHA256' on the csc.exe command-line or populate the '<ChecksumAlgorithm>' project property with 'SHA256' to enable secure source code hashing.\r\nFor native code - use to MSVC 17.0 (14.30.*) or later if possible. For VC projects use PlatformToolset property with 'v143' or later value.\r\nWhen using older MSVC versions add /ZH:SHA_256 on cl.exe command line."
              },
              "help": {
                "text": "Compilers can generate and store checksums of source files in order to provide linkage between binaries, their PDBs, and associated source code.\r\nThis information is typically used to resolve source file when debugging but it can also be used to verify that a specific body of source code is, in fact, the code that was used to produce a specific set of binaries and PDBs.\r\nThis validation is helpful in verifying supply chain integrity. Due to this security focus, it is important that the hashing algorithm used to produce checksums is secure.\r\nLegacy hashing algorithms, such as MD5 and SHA-1, have been demonstrated to be broken by modern hardware (that is, it is computationally feasible to force hash collisions, in which a common hash is generated from distinct files).\r\nUsing a secure hashing algorithm, such as SHA-256, prevents the possibility of collision attacks, in which the checksum of a malicious file is used to produce a hash that satisfies the system that it is, in fact, the original file processed by the compiler.\r\nFor managed binaries, pass '-checksumalgorithm:SHA256' on the csc.exe command-line or populate the '<ChecksumAlgorithm>' project property with 'SHA256' to enable secure source code hashing.\r\nFor native code - use to MSVC 17.0 (14.30.*) or later if possible. For VC projects use PlatformToolset property with 'v143' or later value.\r\nWhen using older MSVC versions add /ZH:SHA_256 on cl.exe command line."
              },
              "messageStrings": {
                "Pass": {
                  "text": "'{0}' is a {1} binary which was compiled with a secure (SHA-256) source code hashing algorithm."
                },
                "Warning_NativeWithInsecureStaticLibraryCompilands": {
                  "text": "'{0}' is a native binary that links one or more static libraries that include object files which were hashed using an insecure checksum algorithm.\r\nInsecure checksum algorithms are subject to collision attacks and its use can compromise supply chain integrity.\r\nTo resolve this issue, use newer versions of libraries that are compiled with /ZH:SHA_256. MSVC: 17.0 (14.30.*) or later. Windows SDK: 10.0.18362.0 or later.\r\nThe following modules are out of policy:\r\n{1}"
                },
                "Error_Managed": {
                  "text": "'{0}' is a managed binary compiled with an insecure ({1}) source code hashing algorithm. {1} is subject to collision attacks and its use can compromise supply chain integrity. Pass '-checksumalgorithm:SHA256' on the csc.exe command-line or populate the project <ChecksumAlgorithm> property with 'SHA256' to enable secure source code hashing."
                },
                "Error_NativeWithInsecureDirectCompilands": {
                  "text": "'{0}' is a native binary that directly compiles and links one or more object files which were hashed using an insecure checksum algorithm.\r\nInsecure checksum algorithms are subject to collision attacks and its use can compromise supply chain integrity.\r\nUse MSVC 17.0 (14.30.*) or later if possible.\r\nWhen using older MSVC versions, pass '/ZH:SHA_256' on the cl.exe command-line to enable secure source code hashing.\r\nThe following modules are out of policy:\r\n{1}"
                },
                "NotApplicable_InvalidMetadata": {
                  "text": "'{0}' was not evaluated for check '{1}' as the analysis is not relevant based on observed metadata: {2}."
                }
              },
              "helpUri": "https://github.com/microsoft/binskim/blob/main/docs/BinSkimRules.md#rule-BA2004EnableSecureSourceCodeHashing"
            },
            {
              "id": "BA2005",
              "name": "DoNotShipVulnerableBinaries",
              "fullDescription": {
                "text": "Do not ship obsolete libraries for which there are known security vulnerabilities."
              },
              "help": {
                "text": "Do not ship obsolete libraries for which there are known security vulnerabilities."
              },
              "messageStrings": {
                "Pass": {
                  "text": "'{0}' is not known to be an obsolete binary that is vulnerable to one or more security problems."
                },
                "Error": {
                  "text": "'{0}' appears to be an obsolete library (version {1}) for which there are known security vulnerabilities. \r\nTo resolve this issue, obtain a version of {0} that is newer than version {2}. If this binary is not in fact {0}, ignore this warning."
                },
                "Error_CouldNotParseVersion": {
                  "text": "Version information for '{0}' could not be parsed. The binary therefore could not be verified not to be an obsolete binary that is known to be vulnerable to one or more security problems."
                },
                "NotApplicable_InvalidMetadata": {
                  "text": "'{0}' was not evaluated for check '{1}' as the analysis is not relevant based on observed metadata: {2}."
                }
              },
              "helpUri": "https://github.com/microsoft/binskim/blob/main/docs/BinSkimRules.md#rule-BA2005DoNotShipVulnerableBinaries",
              "properties": {
                "equivalentBinScopeRuleReadableName": "BinaryVersionsCheck"
              }
            },
            {
              "id": "BA2006",
              "name": "BuildWithSecureTools",
              "fullDescription": {
                "text": "Application code should be compiled with the most up-to-date tool sets possible to take advantage of the most current compile-time security features. \r\nAmong other things, these features provide address space layout randomization, help prevent arbitrary code execution, and enable code generation that can help prevent speculative execution side-channel attacks."
              },
              "help": {
                "text": "Application code should be compiled with the most up-to-date tool sets possible to take advantage of the most current compile-time security features. \r\nAmong other things, these features provide address space layout randomization, help prevent arbitrary code execution, and enable code generation that can help prevent speculative execution side-channel attacks."
              },
              "messageStrings": {
                "Error": {
                  "text": "'{0}' was compiled with one or more modules which were not built using minimum required tool versions (compiler version {1}). More recent toolchains contain mitigations that make it more difficult for an attacker to exploit vulnerabilities in programs they produce.\r\nTo resolve this issue, compile and/or link your binary with more recent tools. If you are servicing a product where the tool chain cannot be modified (e.g. producing a hotfix for an already shipped version) ignore this warning. Modules built outside of policy: \r\n{2}"
                },
                "Error_BadModule": {
                  "text": "built with {0} compiler version {1} (Front end version {2})"
                },
                "Pass": {
                  "text": "All linked modules of '{0}' satisfy configured policy (observed compilers: {1})."
                },
                "NotApplicable_InvalidMetadata": {
                  "text": "'{0}' was not evaluated for check '{1}' as the analysis is not relevant based on observed metadata: {2}."
                }
              },
              "helpUri": "https://github.com/microsoft/binskim/blob/main/docs/BinSkimRules.md#rule-BA2006BuildWithSecureTools",
              "properties": {
                "equivalentBinScopeRuleReadableName": "CompilerVersionCheck"
              }
            },
            {
              "id": "BA2007",
              "name": "EnableCriticalCompilerWarnings",
              "fullDescription": {
                "text": "Binaries should be compiled with a warning level that enables all critical security-relevant checks.\r\nEnabling at least warning level 3 enables important static analysis in the compiler that can identify bugs with a potential to provoke memory corruption, information disclosure, or double-free vulnerabilities.\r\nTo resolve this issue, compile at warning level 3 or higher by supplying /W3, /W4, or /Wall to the compiler, and resolve the warnings emitted.\r\nFor VC projects use %(ClCompile.WarningLevel) ItemDefinitionGroup property with 'Level3', 'Level4' or 'EnableAllWarnings' values."
              },
              "help": {
                "text": "Binaries should be compiled with a warning level that enables all critical security-relevant checks.\r\nEnabling at least warning level 3 enables important static analysis in the compiler that can identify bugs with a potential to provoke memory corruption, information disclosure, or double-free vulnerabilities.\r\nTo resolve this issue, compile at warning level 3 or higher by supplying /W3, /W4, or /Wall to the compiler, and resolve the warnings emitted.\r\nFor VC projects use %(ClCompile.WarningLevel) ItemDefinitionGroup property with 'Level3', 'Level4' or 'EnableAllWarnings' values."
              },
              "messageStrings": {
                "Pass": {
                  "text": "'{0}' was compiled at a secure warning level ({1}) and does not include any modules that disable specific warnings that are required by policy. As a result, it is less likely that memory corruption, information disclosure, double-free and other security-related vulnerabilities exist in code."
                },
                "Error_WarningsDisabled": {
                  "text": "'{0}' disables compiler warning(s) which are required by policy. A compiler warning is typically required if it has a high likelihood of flagging memory corruption, information disclosure, or double-free vulnerabilities.\r\nTo resolve this issue, enable the indicated warning(s) by removing /Wxxxx switches (where xxxx is a warning id indicated here) from your command line, and resolve any warnings subsequently raised during compilation.\r\nFor VC projects check ItemDefinitionGroup - ClCompile - DisableSpecificWarnings property.\r\nAn example compiler command line triggering this check was: {1}\r\nModules triggering this check were:\r\n{2}"
                },
                "Error_InsufficientWarningLevel": {
                  "text": "'{0}' was compiled at too low a warning level (effective warning level {1} for one or more modules).\r\nWarning level 3 enables important static analysis in the compiler to flag bugs that can lead to memory corruption, information disclosure, or double-free vulnerabilities.\r\nTo resolve this issue, compile at warning level 3 or higher by supplying /W3, /W4, or /Wall to the compiler, and resolve the warnings emitted.\r\nFor VC projects use ItemDefinitionGroup - ClCompile - WarningLevel property with 'Level3', 'Level4' or 'EnableAllWarnings' values. An example compiler command line triggering this check: {2}\r\nModules triggering this check: {3}"
                },
                "Error_UnknownModuleLanguage": {
                  "text": "'{0}' contains code from an unknown language, preventing a comprehensive analysis of the compiler warning settings. The language could not be identified for the following modules: {1}"
                },
                "NotApplicable_InvalidMetadata": {
                  "text": "'{0}' was not evaluated for check '{1}' as the analysis is not relevant based on observed metadata: {2}."
                }
              },
              "helpUri": "https://github.com/microsoft/binskim/blob/main/docs/BinSkimRules.md#rule-BA2007EnableCriticalCompilerWarnings",
              "properties": {
                "equivalentBinScopeRuleReadableName": "CompilerWarningsCheck"
              }
            },
            {
              "id": "BA2008",
              "name": "EnableControlFlowGuard",
              "fullDescription": {
                "text": "Binaries should enable the compiler control guard feature (CFG) at build time to prevent attackers from redirecting execution to unexpected, unsafe locations. CFG analyzes and discovers all indirect-call instructions at compilation and link time. It also injects a check that precedes every indirect call in code that ensures the target is an expected, safe location.  If that check fails at runtime, the operating system will close the program."
              },
              "help": {
                "text": "Binaries should enable the compiler control guard feature (CFG) at build time to prevent attackers from redirecting execution to unexpected, unsafe locations. CFG analyzes and discovers all indirect-call instructions at compilation and link time. It also injects a check that precedes every indirect call in code that ensures the target is an expected, safe location.  If that check fails at runtime, the operating system will close the program."
              },
              "messageStrings": {
                "Pass": {
                  "text": "'{0}' enables the control flow guard mitigation. As a result, the operating system will force an application to close if an attacker is able to redirect execution in the component to an unexpected location."
                },
                "Error": {
                  "text": "'{0}' does not enable the control flow guard (CFG) mitigation.\r\nTo resolve this issue, pass /guard:cf on both the compiler and linker command lines. Binaries also require the /DYNAMICBASE linker option in order to enable CFG.\r\nFor VC projects use ItemDefinitionGroup - ClCompile - ControlFlowGuard property with 'Guard' value, link CFG property will be set automatically."
                },
                "NotApplicable_InvalidMetadata": {
                  "text": "'{0}' was not evaluated for check '{1}' as the analysis is not relevant based on observed metadata: {2}."
                },
                "NotApplicable_UnsupportedKernelModeVersion": {
                  "text": "'{0}' is a kernel mode portable executable compiled for a version of Windows that does not support the control flow guard feature for kernel mode binaries."
                }
              },
              "helpUri": "https://github.com/microsoft/binskim/blob/main/docs/BinSkimRules.md#rule-BA2008EnableControlFlowGuard",
              "properties": {
                "equivalentBinScopeRuleReadableName": "ControlFlowGuardCheck"
              }
            },
            {
              "id": "BA2009",
              "name": "EnableAddressSpaceLayoutRandomization",
              "fullDescription": {
                "text": "Binaries should linked as DYNAMICBASE to be eligible for relocation by Address Space Layout Randomization (ASLR). ASLR is an important mitigation that makes it more difficult for an attacker to exploit memory corruption vulnerabilities. Configure your tools to build with this feature enabled. For C and C++ binaries, add /DYNAMICBASE to your linker command line. For .NET applications, use a compiler shipping with Visual Studio 2008 or later."
              },
              "help": {
                "text": "Binaries should linked as DYNAMICBASE to be eligible for relocation by Address Space Layout Randomization (ASLR). ASLR is an important mitigation that makes it more difficult for an attacker to exploit memory corruption vulnerabilities. Configure your tools to build with this feature enabled. For C and C++ binaries, add /DYNAMICBASE to your linker command line. For .NET applications, use a compiler shipping with Visual Studio 2008 or later."
              },
              "messageStrings": {
                "Pass": {
                  "text": "'{0}' is properly compiled to enable Address Space Layout Randomization, reducing an attacker's ability to exploit code in well-known locations."
                },
                "Error_NotDynamicBase": {
                  "text": "'{0}' is not marked as DYNAMICBASE. This means that the binary is not eligible for relocation by Address Space Layout Randomization (ASLR). ASLR is an important mitigation that makes it more difficult for an attacker to exploit memory corruption vulnerabilities.\r\nTo resolve this issue, configure your tools to build with this feature enabled. For C and C++ binaries, add /DYNAMICBASE to your linker command line.\r\nFor VC projects use ItemDefinitionGroup - Link - RandomizedBaseAddress property with 'true' value.\r\nFor .NET applications, use a compiler shipping with Visual Studio 2008 or later."
                },
                "Error_RelocsStripped": {
                  "text": "'{0}' is marked as DYNAMICBASE but relocation data has been stripped from the image, preventing address space layout randomization. "
                },
                "Error_WinCENoRelocationSection": {
                  "text": "'{0}' is a Windows CE image but does not contain any relocation data, preventing Address Space Layout Randomization."
                },
                "NotApplicable_InvalidMetadata": {
                  "text": "'{0}' was not evaluated for check '{1}' as the analysis is not relevant based on observed metadata: {2}."
                }
              },
              "helpUri": "https://github.com/microsoft/binskim/blob/main/docs/BinSkimRules.md#rule-BA2009EnableAddressSpaceLayoutRandomization",
              "properties": {
                "equivalentBinScopeRuleReadableName": "DBCheck"
              }
            },
            {
              "id": "BA2010",
              "name": "DoNotMarkImportsSectionAsExecutable",
              "fullDescription": {
                "text": "PE sections should not be marked as both writable and executable. This condition makes it easier for an attacker to exploit memory corruption vulnerabilities, as it may provide an attacker executable location(s) to inject shellcode. Because the loader will always mark the imports section as writable, it is therefore important to mark this section as non-executable.\r\nTo resolve this issue, ensure that your program does not mark the imports section executable. Look for uses of /SECTION or /MERGE on the linker command line, or #pragma segment in source code, which change the imports section to be executable, or which merge the \".rdata\" segment into an executable section."
              },
              "help": {
                "text": "PE sections should not be marked as both writable and executable. This condition makes it easier for an attacker to exploit memory corruption vulnerabilities, as it may provide an attacker executable location(s) to inject shellcode. Because the loader will always mark the imports section as writable, it is therefore important to mark this section as non-executable.\r\nTo resolve this issue, ensure that your program does not mark the imports section executable. Look for uses of /SECTION or /MERGE on the linker command line, or #pragma segment in source code, which change the imports section to be executable, or which merge the \".rdata\" segment into an executable section."
              },
              "messageStrings": {
                "Pass": {
                  "text": "'{0}' does not have an imports section that is marked as executable, helping to prevent the exploitation of code vulnerabilities."
                },
                "Error": {
                  "text": "'{0}' has the imports section marked executable. Because the loader will always mark the imports section as writable, it is important to mark this section as non-executable, so that an attacker cannot place shellcode here.\r\nTo resolve this issue, ensure that your program does not mark the imports section as executable. Look for uses of /SECTION or /MERGE on the linker command line, or #pragma segment in source code, which change the imports section to be executable, or which merge the \".rdata\" segment into an executable section."
                },
                "NotApplicable_InvalidMetadata": {
                  "text": "'{0}' was not evaluated for check '{1}' as the analysis is not relevant based on observed metadata: {2}."
                }
              },
              "helpUri": "https://github.com/microsoft/binskim/blob/main/docs/BinSkimRules.md#rule-BA2010DoNotMarkImportsSectionAsExecutable",
              "properties": {
                "equivalentBinScopeRuleReadableName": "ExecutableImportsCheck"
              }
            },
            {
              "id": "BA2011",
              "name": "EnableStackProtection",
              "fullDescription": {
                "text": "Binaries should be built with the stack protector buffer security feature (/GS) enabled to increase the difficulty of exploiting stack buffer overflow memory corruption vulnerabilities.\r\nTo resolve this issue, ensure that all modules compiled into the binary are compiled with the stack protector enabled by supplying /GS on the cl.exe command line.\r\nFor VC projects use ItemDefinitionGroup - ClCompile - BufferSecurityCheck property with 'true' value."
              },
              "help": {
                "text": "Binaries should be built with the stack protector buffer security feature (/GS) enabled to increase the difficulty of exploiting stack buffer overflow memory corruption vulnerabilities.\r\nTo resolve this issue, ensure that all modules compiled into the binary are compiled with the stack protector enabled by supplying /GS on the cl.exe command line.\r\nFor VC projects use ItemDefinitionGroup - ClCompile - BufferSecurityCheck property with 'true' value."
              },
              "messageStrings": {
                "Pass": {
                  "text": "'{0}' is a C or C++ binary built with the stack protector buffer security feature enabled for all modules, making it more difficult for an attacker to exploit stack buffer overflow memory corruption vulnerabilities. "
                },
                "Error": {
                  "text": "'{0}' is a C or C++ binary built with the stack protector buffer security feature disabled in one or more modules. The stack protector (/GS) is a security feature of the compiler which makes it more difficult to exploit stack buffer overflow memory corruption vulnerabilities.\r\nTo resolve this issue, ensure that your code is compiled with the stack protector enabled by supplying /GS on cl.exe command line.\r\nFor VC projects use ItemDefinitionGroup - ClCompile - BufferSecurityCheck property with 'true' value.\r\nThe affected modules were: {1}"
                },
                "Error_UnknownModuleLanguage": {
                  "text": "'{0}' contains code from an unknown language, preventing a comprehensive analysis of the stack protector buffer security features. The language could not be identified for the following modules: {1}."
                },
                "NotApplicable_InvalidMetadata": {
                  "text": "'{0}' was not evaluated for check '{1}' as the analysis is not relevant based on observed metadata: {2}."
                }
              },
              "helpUri": "https://github.com/microsoft/binskim/blob/main/docs/BinSkimRules.md#rule-BA2011EnableStackProtection",
              "properties": {
                "equivalentBinScopeRuleReadableName": "GSCheck"
              }
            },
            {
              "id": "BA2012",
              "name": "DoNotModifyStackProtectionCookie",
              "fullDescription": {
                "text": "Application code should not interfere with the stack protector. The stack protector (/GS) is a security feature of the compiler which makes it more difficult to exploit stack buffer overflow memory corruption vulnerabilities. \r\nThe stack protector relies on a random number, called the \"security cookie\", to detect these buffer overflows. This 'cookie' is statically linked with your binary from a Visual C++ library in the form of the symbol __security_cookie.\r\nOn recent Windows versions, the loader looks for the statically linked value of this cookie, and initializes the cookie with a far better source of entropy -- the system's secure random number generator -- rather than the limited random number generator available early in the C runtime startup code.\r\nWhen this symbol is not the default value, the additional entropy is not injected by the operating system, reducing the effectiveness of the stack protector.\r\nTo resolve this issue, ensure that your code does not reference or create a symbol named __security_cookie or __security_cookie_complement."
              },
              "help": {
                "text": "Application code should not interfere with the stack protector. The stack protector (/GS) is a security feature of the compiler which makes it more difficult to exploit stack buffer overflow memory corruption vulnerabilities. \r\nThe stack protector relies on a random number, called the \"security cookie\", to detect these buffer overflows. This 'cookie' is statically linked with your binary from a Visual C++ library in the form of the symbol __security_cookie.\r\nOn recent Windows versions, the loader looks for the statically linked value of this cookie, and initializes the cookie with a far better source of entropy -- the system's secure random number generator -- rather than the limited random number generator available early in the C runtime startup code.\r\nWhen this symbol is not the default value, the additional entropy is not injected by the operating system, reducing the effectiveness of the stack protector.\r\nTo resolve this issue, ensure that your code does not reference or create a symbol named __security_cookie or __security_cookie_complement."
              },
              "messageStrings": {
                "Pass": {
                  "text": "'{0}' is a C or C++ binary built with the buffer security feature that properly preserves the stack protecter cookie. This has the effect of enabling a significant increase in entropy provided by the operating system over that produced by the C runtime start-up code."
                },
                "Pass_NoLoadConfig": {
                  "text": "'{0}' is  C or C++binary that does not contain a load config table, which indicates either that it was compiled and linked with a version of the compiler that precedes stack protection features or is a binary (such as an ngen'ed assembly) that is not subject to relevant security issues."
                },
                "Error": {
                  "text": "'{0}' is a C or C++ binary that interferes with the stack protector. The stack protector (/GS) is a security feature of the compiler which makes it more difficult to exploit stack buffer overflow memory corruption vulnerabilities.\r\nThe stack protector relies on a random number, called the \"security cookie\", to detect these buffer overflows. This 'cookie' is statically linked with your binary from a Visual C++ library in the form of the symbol __security_cookie.\r\nOn recent Windows versions, the loader looks for the magic statically linked value of this cookie, and initializes the cookie with a far better source of entropy -- the system's secure random number generator -- rather than the limited random number generator available early in the C runtime startup code.\r\nWhen this symbol is not the default value, the additional entropy is not injected by the operating system, reducing the effectiveness of the stack protector.\r\nTo resolve this issue, ensure that your code does not reference or create a symbol named __security_cookie or __security_cookie_complement.\r\nNOTE: the modified cookie value detected was: {1}"
                },
                "Error_CouldNotLocateCookie": {
                  "text": "'{0}' is a C or C++binary that enables the stack protection feature but the security cookie could not be located. The binary may be corrupted."
                },
                "Warning_InvalidSecurityCookieOffset": {
                  "text": "'{0}' appears to be a packed C or C++ binary that reports a security cookie offset that exceeds the size of the packed file. Use of the stack protector (/GS) feature therefore could not be verified. The file was possibly packed by: {1}."
                },
                "NotApplicable_InvalidMetadata": {
                  "text": "'{0}' was not evaluated for check '{1}' as the analysis is not relevant based on observed metadata: {2}."
                }
              },
              "helpUri": "https://github.com/microsoft/binskim/blob/main/docs/BinSkimRules.md#rule-BA2012DoNotModifyStackProtectionCookie",
              "properties": {
                "equivalentBinScopeRuleReadableName": "DefaultGSCookieCheck"
              }
            },
            {
              "id": "BA2013",
              "name": "InitializeStackProtection",
              "fullDescription": {
                "text": "Binaries should properly initialize the stack protector (/GS) in order to increase the difficulty of exploiting stack buffer overflow memory corruption vulnerabilities.\r\nThe stack protector requires access to entropy in order to be effective, which means a binary must initialize a random number generator at startup, by calling __security_init_cookie() as close to the binary's entry point as possible. Failing to do so will result in spurious buffer overflow detections on the part of the stack protector.\r\nTo resolve this issue, use the default entry point provided by the C runtime, which will make this call for you, or call __security_init_cookie() manually in your custom entry point."
              },
              "help": {
                "text": "Binaries should properly initialize the stack protector (/GS) in order to increase the difficulty of exploiting stack buffer overflow memory corruption vulnerabilities.\r\nThe stack protector requires access to entropy in order to be effective, which means a binary must initialize a random number generator at startup, by calling __security_init_cookie() as close to the binary's entry point as possible. Failing to do so will result in spurious buffer overflow detections on the part of the stack protector.\r\nTo resolve this issue, use the default entry point provided by the C runtime, which will make this call for you, or call __security_init_cookie() manually in your custom entry point."
              },
              "messageStrings": {
                "Pass": {
                  "text": "'{0}' is a C or C++ binary built with the buffer security feature that properly initializes the stack protecter. This has the effect of increasing the effectiveness of the feature and reducing spurious detections."
                },
                "Pass_NoCode": {
                  "text": "'{0}' is a C or C++ binary that is not required to initialize the stack protection, as it does not contain executable code."
                },
                "NotApplicable_FeatureNotEnabled": {
                  "text": "'{0}' is a C or C++ binary that does not enable the stack protection buffer security feature. It is therefore not required to initialize the stack protector."
                },
                "Error": {
                  "text": "'{0}' is a C or C++ binary that does not initialize the stack protector. The stack protector (/GS) is a security feature of the compiler which makes it more difficult to exploit stack buffer overflow memory corruption vulnerabilities.\r\nThe stack protector requires access to entropy in order to be effective, which means a binary must initialize a random number generator at startup, by calling __security_init_cookie() as close to the binary's entry point as possible. Failing to do so will result in spurious buffer overflow detections on the part of the stack protector.\r\nTo resolve this issue, use the default entry point provided by the C runtime, which will make this call for you, or call __security_init_cookie() manually in your custom entry point."
                },
                "NotApplicable_InvalidMetadata": {
                  "text": "'{0}' was not evaluated for check '{1}' as the analysis is not relevant based on observed metadata: {2}."
                }
              },
              "helpUri": "https://github.com/microsoft/binskim/blob/main/docs/BinSkimRules.md#rule-BA2013InitializeStackProtection",
              "properties": {
                "equivalentBinScopeRuleReadableName": "GSFriendlyInitCheck"
              }
            },
            {
              "id": "BA2014",
              "name": "DoNotDisableStackProtectionForFunctions",
              "fullDescription": {
                "text": "Application code should not disable stack protection for individual functions. The stack protector (/GS) is a security feature of the Windows native compiler which makes it more difficult to exploit stack buffer overflow memory corruption vulnerabilities.\r\nDisabling the stack protector, even on a function-by-function basis, can compromise the security of code.\r\nTo resolve this issue, remove occurrences of __declspec(safebuffers) from your code.\r\nIf the additional code inserted by the stack protector has been shown in profiling to cause a significant performance problem for your application, attempt to move stack buffer modifications out of the hot path of execution to allow the compiler to avoid inserting stack protector checks in these locations rather than disabling the stack protector altogether."
              },
              "help": {
                "text": "Application code should not disable stack protection for individual functions. The stack protector (/GS) is a security feature of the Windows native compiler which makes it more difficult to exploit stack buffer overflow memory corruption vulnerabilities.\r\nDisabling the stack protector, even on a function-by-function basis, can compromise the security of code.\r\nTo resolve this issue, remove occurrences of __declspec(safebuffers) from your code.\r\nIf the additional code inserted by the stack protector has been shown in profiling to cause a significant performance problem for your application, attempt to move stack buffer modifications out of the hot path of execution to allow the compiler to avoid inserting stack protector checks in these locations rather than disabling the stack protector altogether."
              },
              "messageStrings": {
                "Pass": {
                  "text": "'{0}' is a C or C++ binary built with the stack protector buffer security feature enabled which does not disable protection for any individual functions (via __declspec(safebuffers), making it more difficult for an attacker to exploit stack buffer overflow memory corruption vulnerabilities."
                },
                "Error": {
                  "text": "'{0}' is a C or C++ binary built with function(s) ({1}) that disable the stack protector. The stack protector (/GS) is a security feature of the compiler which makes it more difficult to exploit stack buffer overflow memory corruption vulnerabilities.\r\nDisabling the stack protector, even on a function-by-function basis, is disallowed by SDL policy.\r\nTo resolve this issue, remove occurrences of __declspec(safebuffers) from your code.\r\nIf the additional code inserted by the stack protector has been shown in profiling to cause a significant performance problem for your application, attempt to move stack buffer modifications out of the hot path of execution to allow the compiler to avoid inserting stack protector checks in these locations rather than disabling the stack protector altogether."
                },
                "NotApplicable_InvalidMetadata": {
                  "text": "'{0}' was not evaluated for check '{1}' as the analysis is not relevant based on observed metadata: {2}."
                }
              },
              "helpUri": "https://github.com/microsoft/binskim/blob/main/docs/BinSkimRules.md#rule-BA2014DoNotDisableStackProtectionForFunctions",
              "properties": {
                "equivalentBinScopeRuleReadableName": "GSFunctionSafeBuffersCheck"
              }
            },
            {
              "id": "BA2015",
              "name": "EnableHighEntropyVirtualAddresses",
              "fullDescription": {
                "text": "Binaries should be marked as high entropy Address Space Layout Randomization (ASLR) compatible. High entropy allows ASLR to be more effective in mitigating memory corruption vulnerabilities.\r\nTo resolve this issue, don't set /HIGHENTROPYV:NO on link.exe command line and allow it to be enabled by default. "
              },
              "help": {
                "text": "Binaries should be marked as high entropy Address Space Layout Randomization (ASLR) compatible. High entropy allows ASLR to be more effective in mitigating memory corruption vulnerabilities.\r\nTo resolve this issue, don't set /HIGHENTROPYV:NO on link.exe command line and allow it to be enabled by default. "
              },
              "messageStrings": {
                "Pass": {
                  "text": "'{0}' is high entropy ASLR compatible, reducing an attacker's ability to exploit code in well-known locations."
                },
                "Error_NoHighEntropyVA": {
                  "text": "'{0}' does not declare itself as high entropy ASLR compatible. High entropy makes Address Space Layout Randomization more effective in mitigating memory corruption vulnerabilities.\r\nTo resolve this issue, don't set /HIGHENTROPYVA:NO on link.exe command line and allow it to be enabled by default. (This image was determined to have been properly compiled as /LARGEADDRESSAWARE.)"
                },
                "Error_NoLargeAddressAware": {
                  "text": "'{0}' does not declare itself as high entropy ASLR compatible. High entropy makes Address Space Layout Randomization more effective in mitigating memory corruption vulnerabilities.\r\nTo resolve this issue, don't set /LARGEADDRESSAWARE:NO on link.exe command line and allow it to be enabled by default. (This image was determined to have been properly compiled as /HIGHENTROPYVA.)"
                },
                "Error_NeitherHighEntropyVANorLargeAddressAware": {
                  "text": "'{0}' does not declare itself as high entropy ASLR compatible. High entropy makes Address Space Layout Randomization more effective in mitigating memory corruption vulnerabilities.\r\nTo resolve this issue, don't set /HIGHENTROPYVA:NO and /LARGEADDRESSAWARE:NO on link.exe command line and allow then to be enabled by default."
                },
                "NotApplicable_InvalidMetadata": {
                  "text": "'{0}' was not evaluated for check '{1}' as the analysis is not relevant based on observed metadata: {2}."
                }
              },
              "helpUri": "https://github.com/microsoft/binskim/blob/main/docs/BinSkimRules.md#rule-BA2015EnableHighEntropyVirtualAddresses",
              "properties": {
                "equivalentBinScopeRuleReadableName": "HighEntropyVACheck"
              }
            },
            {
              "id": "BA2019",
              "name": "DoNotMarkWritableSectionsAsShared",
              "fullDescription": {
                "text": "Code or data sections should not be marked as both shared and writable. Because these sections are shared across processes, this condition might permit a process with low privilege to alter memory in a higher privilege process.\r\nIf you do not actually require that a section be both writable and shared, remove one or both of these attributes (by modifying your .DEF file, the appropriate linker /section switch arguments, etc.).\r\nIf you must share common data across processes (for inter-process communication (IPC) or other purposes) use CreateFileMapping with proper security attributes or an actual IPC mechanism instead (COM, named pipes, LPC, etc.)."
              },
              "help": {
                "text": "Code or data sections should not be marked as both shared and writable. Because these sections are shared across processes, this condition might permit a process with low privilege to alter memory in a higher privilege process.\r\nIf you do not actually require that a section be both writable and shared, remove one or both of these attributes (by modifying your .DEF file, the appropriate linker /section switch arguments, etc.).\r\nIf you must share common data across processes (for inter-process communication (IPC) or other purposes) use CreateFileMapping with proper security attributes or an actual IPC mechanism instead (COM, named pipes, LPC, etc.)."
              },
              "messageStrings": {
                "Pass": {
                  "text": "'{0}' contains no data or code sections marked as both shared and writable, helping to prevent the exploitation of code vulnerabilities."
                },
                "Error": {
                  "text": "'{0}' contains one or more code or data sections ({1}) which are marked as both shared and writable. Because these sections are shared across processes, this condition might permit a process with low privilege to alter memory in a higher privilege process.\r\nIf you do not actually require that a section be both writable and shared, remove one or both of these attributes (by modifying your .DEF file, the appropriate linker /section switch arguments, etc.).\r\nIf you must share common data across processes (for inter-process communication (IPC) or other purposes) use CreateFileMapping with proper security attributes or an actual IPC mechanism instead (COM, named pipes, LPC, etc.)."
                },
                "NotApplicable_InvalidMetadata": {
                  "text": "'{0}' was not evaluated for check '{1}' as the analysis is not relevant based on observed metadata: {2}."
                }
              },
              "helpUri": "https://github.com/microsoft/binskim/blob/main/docs/BinSkimRules.md#rule-BA2019DoNotMarkWritableSectionsAsShared",
              "properties": {
                "equivalentBinScopeRuleReadableName": "SharedSectionCheck"
              }
            },
            {
              "id": "BA2021",
              "name": "DoNotMarkWritableSectionsAsExecutable",
              "fullDescription": {
                "text": "PE sections should not be marked as both writable and executable. This condition makes it easier for an attacker to exploit memory corruption vulnerabilities, as it may provide an attacker executable location(s) to inject shellcode.\r\nTo resolve this issue, configure your tools to not emit memory sections that are writable and executable. For example, look for uses of /SECTION on the linker command line for C and C++ programs, or #pragma section in C and C++ source code, which mark a section with both attributes.\r\nBe sure to disable incremental linking in release builds, as this feature creates a writable and executable section named '.textbss' in order to function."
              },
              "help": {
                "text": "PE sections should not be marked as both writable and executable. This condition makes it easier for an attacker to exploit memory corruption vulnerabilities, as it may provide an attacker executable location(s) to inject shellcode.\r\nTo resolve this issue, configure your tools to not emit memory sections that are writable and executable. For example, look for uses of /SECTION on the linker command line for C and C++ programs, or #pragma section in C and C++ source code, which mark a section with both attributes.\r\nBe sure to disable incremental linking in release builds, as this feature creates a writable and executable section named '.textbss' in order to function."
              },
              "messageStrings": {
                "Pass": {
                  "text": "'{0}' contains no data or code sections marked as both shared and executable, helping to prevent the exploitation of code vulnerabilities."
                },
                "Error": {
                  "text": "'{0}' contains PE section(s) ({1}) that are both writable and executable. Writable and executable memory segments make it easier for an attacker to exploit memory corruption vulnerabilities, because it may provide an attacker executable location(s) to inject shellcode.\r\nTo resolve this issue, configure your tools to not emit memory sections that are writable and executable. For example, look for uses of /SECTION on the linker command line for C and C++ programs, or #pragma section in C and C++ source code, which mark a section with both attributes.\r\nEnabling incremental linking via the /INCREMENTAL argument (the default for Microsoft Visual Studio debug build) can also result in a writable and executable section named 'textbss'. For this case, disable incremental linking (or analyze an alternate build configuration that disables this feature) to resolve the problem.\r\nFor VC projects use ItemDefinitionGroup - Link - LinkIncremental property with 'false' value."
                },
                "Error_UnexpectedSectionAligment": {
                  "text": "'{0}' has a section alignment ({1}) that is smaller than its page size ({2})."
                },
                "NotApplicable_InvalidMetadata": {
                  "text": "'{0}' was not evaluated for check '{1}' as the analysis is not relevant based on observed metadata: {2}."
                }
              },
              "helpUri": "https://github.com/microsoft/binskim/blob/main/docs/BinSkimRules.md#rule-BA2021DoNotMarkWritableSectionsAsExecutable",
              "properties": {
                "equivalentBinScopeRuleReadableName": "WXCheck"
              }
            },
            {
              "id": "BA2024",
              "name": "EnableSpectreMitigations",
              "fullDescription": {
                "text": "Application code which stores sensitive data in memory should be compiled with the Spectre mitigations switch (/Qspectre cl.exe command-line argument or <SpectreMitigation>Spectre</SpectreMitigation> build property).\r\nSpectre attacks can compromise hardware-based isolation, allowing non-privileged users to retrieve potentially sensitive data from the CPU cache.\r\nTo resolve this issue, ensure that all modules compiled into the binary are compiled with /Qspectre switch on cl.exe command-line.\r\nYou may need to install the 'C++ spectre-mitigated libs' component from the Visual Studio installer if you observe violations against C runtime libraries such as libcmt.lib, libvcruntime.lib, etc.\r\nFor VC projects use SpectreMitigation property with 'Spectre' value.\r\nWhen using older MSVC versions pass /d2guardspecload in cases where your compiler supports this switch and it is not possible to update to a toolset that supports /Qspectre.\r\nThis warning should be addressed for code that operates on data that crosses a trust boundary and that can affect execution, such as parsing untrusted file inputs or processing query strings of a web request.\r\nFor mitigation to be effective, all dlls and libs that are part of an exe, should be compiled with /QSpectre, so decision should be made for the whole process.\r\nCan cause some perf degradations, so should not be used when not needed."
              },
              "help": {
                "text": "Application code which stores sensitive data in memory should be compiled with the Spectre mitigations switch (/Qspectre cl.exe command-line argument or <SpectreMitigation>Spectre</SpectreMitigation> build property).\r\nSpectre attacks can compromise hardware-based isolation, allowing non-privileged users to retrieve potentially sensitive data from the CPU cache.\r\nTo resolve this issue, ensure that all modules compiled into the binary are compiled with /Qspectre switch on cl.exe command-line.\r\nYou may need to install the 'C++ spectre-mitigated libs' component from the Visual Studio installer if you observe violations against C runtime libraries such as libcmt.lib, libvcruntime.lib, etc.\r\nFor VC projects use SpectreMitigation property with 'Spectre' value.\r\nWhen using older MSVC versions pass /d2guardspecload in cases where your compiler supports this switch and it is not possible to update to a toolset that supports /Qspectre.\r\nThis warning should be addressed for code that operates on data that crosses a trust boundary and that can affect execution, such as parsing untrusted file inputs or processing query strings of a web request.\r\nFor mitigation to be effective, all dlls and libs that are part of an exe, should be compiled with /QSpectre, so decision should be made for the whole process.\r\nCan cause some perf degradations, so should not be used when not needed."
              },
              "messageStrings": {
                "Warning": {
                  "text": "'{0}' was compiled with one or more modules that do not enable code generation mitigations for speculative execution side-channel attack (Spectre) vulnerabilities.\r\nSpectre attacks can compromise hardware-based isolation, allowing non-privileged users to retrieve potentially sensitive data from the CPU cache.\r\nTo resolve this issue, ensure that all modules compiled into the binary are compiled with /Qspectre switch on cl.exe command-line.\r\nYou may need to install the 'C++ spectre-mitigated libs' component from the Visual Studio installer if you observe violations against C runtime libraries such as libcmt.lib, libvcruntime.lib, etc.\r\nFor VC projects use SpectreMitigation property with 'Spectre' value.\r\nWhen using older MSVC versions pass /d2guardspecload in cases where your compiler supports this switch and it is not possible to update to a toolset that supports /Qspectre.\r\nThis warning should be addressed for code that operates on data that crosses a trust boundary and that can affect execution, such as parsing untrusted file inputs or processing query strings of a web request.\r\nFor mitigation to be effective, all dlls and libs that are part of an exe, should be compiled with /QSpectre, so decision should be made for the whole process.\r\nCan cause some perf degradations, so should not be used when not needed."
                },
                "WarningMissingCommandLine": {
                  "text": "{0}' was compiled with one or more modules with a toolset that supports /Qspectre but a compiland `RawCommandLine` value is missing and the rule is therefore not able to determine if `/Qspectre` is specified.\r\nThe likely cause is that the code was linked to a static library with no debug information.  It is not known whether code generation mitigations for speculative execution side-channel attack (Spectre) vulnerabilities was enabled.\r\nSpectre attacks can compromise hardware-based isolation, allowing non-privileged users to retrieve potentially sensitive data from the CPU cache.\r\nTo resolve the issue, ensure that the static library pdb is availble or compile static library code with /Z7 switch which makes symbols to be included in .obj.\r\nFor VC projects use ItemDefinitionGroup - ClCompile - DebugInformationFormat property with 'ProgramDatabase' (/Zi) or 'OldStyle' (/Z7) value."
                },
                "Warning_SpectreMitigationUnknownNoCommandLine": {
                  "text": "The following modules were compiled with a toolset that supports /Qspectre but a compiland `RawCommandLine` value is missing and the rule is therefore not able to determine if `/Qspectre` is specified.\r\nThe likely cause is that the code was linked to a static library with no debug information: {0}"
                },
                "Warning_OptimizationsDisabled": {
                  "text": "The following modules were compiled with optimizations disabled (/Od), a condition that disables Spectre mitigations:\r\n{0}"
                },
                "Warning_SpectreMitigationNotEnabled": {
                  "text": "The following modules were compiled with a toolset that supports /Qspectre but the switch was not enabled on the command-line:\r\n{0}"
                },
                "Warning_SpectreMitigationExplicitlyDisabled": {
                  "text": "The following modules were compiled with Spectre mitigations explicitly disabled:\r\n{0}"
                },
                "Pass": {
                  "text": "All linked modules '{0}' were compiled with mitigations enabled that help prevent Spectre (speculative execution side-channel attack) vulnerabilities."
                },
                "NotApplicable_InvalidMetadata": {
                  "text": "'{0}' was not evaluated for check '{1}' as the analysis is not relevant based on observed metadata: {2}."
                }
              },
              "helpUri": "https://github.com/microsoft/binskim/blob/main/docs/BinSkimRules.md#rule-BA2024EnableSpectreMitigations"
            },
            {
              "id": "BA2025",
              "name": "EnableShadowStack",
              "fullDescription": {
                "text": "Control-flow Enforcement Technology (CET) Shadow Stack is a computer processor feature that provides capabilities to defend against return-oriented programming (ROP) based malware attacks. Note: older versions of .NET are not compatible with CET/shadow stack technology. If your native process loads older managed assemblies (.NET 6 or earlier), unhandled exceptions in those components may not be handled properly and may cause your process to crash."
              },
              "help": {
                "text": "Control-flow Enforcement Technology (CET) Shadow Stack is a computer processor feature that provides capabilities to defend against return-oriented programming (ROP) based malware attacks. Note: older versions of .NET are not compatible with CET/shadow stack technology. If your native process loads older managed assemblies (.NET 6 or earlier), unhandled exceptions in those components may not be handled properly and may cause your process to crash."
              },
              "messageStrings": {
                "Pass": {
                  "text": "'{0}' enables the Control-flow Enforcement Technology (CET) Shadow Stack mitigation."
                },
                "Warning": {
                  "text": "'{0}' does not enable the Control-flow Enforcement Technology (CET) Shadow Stack mitigation.\r\nTo resolve this issue, pass /CETCOMPAT on the linker command lines.\r\nFor VC projects use ItemDefinitionGroup - Link - CETCompat property with 'true' value.\r\nNote: older .NET versions are not compatible with CET/shadow stack technology. If your native process loads older managed assemblies (.NET 6 or earlier), unhandled exceptions in those components may not be handled properly and may cause your process to crash."
                },
                "NotApplicable_InvalidMetadata": {
                  "text": "'{0}' was not evaluated for check '{1}' as the analysis is not relevant based on observed metadata: {2}."
                }
              },
              "helpUri": "https://github.com/microsoft/binskim/blob/main/docs/BinSkimRules.md#rule-BA2025EnableShadowStack"
            },
            {
              "id": "BA2026",
              "name": "EnableMicrosoftCompilerSdlSwitch",
              "fullDescription": {
                "text": "/sdl enables a superset of the baseline security checks provided by /GS and overrides /GS-. By default, /sdl is off. /sdl- disables the additional security checks."
              },
              "help": {
                "text": "/sdl enables a superset of the baseline security checks provided by /GS and overrides /GS-. By default, /sdl is off. /sdl- disables the additional security checks."
              },
              "messageStrings": {
                "Pass": {
                  "text": "'{0}' is a Windows PE that was compiled with recommended Security Development Lifecycle (SDL) checks. These checks change security-relevant warnings into errors, and set additional secure code-generation features."
                },
                "Warning": {
                  "text": "'{0}' is a Windows PE that wasn't compiled with recommended Security Development Lifecycle (SDL) checks. As a result some critical compile-time and runtime checks may be disabled, increasing the possibility of an exploitable runtime issue.\r\nTo resolve this problem, pass '/sdl' on the cl.exe command-line.\r\nFor VC projects use ItemDefinitionGroup - ClCompile - SDLCheck property with 'true' value."
                },
                "NotApplicable_InvalidMetadata": {
                  "text": "'{0}' was not evaluated for check '{1}' as the analysis is not relevant based on observed metadata: {2}."
                }
              },
              "helpUri": "https://github.com/microsoft/binskim/blob/main/docs/BinSkimRules.md#rule-BA2026EnableMicrosoftCompilerSdlSwitch"
            },
            {
              "id": "BA2027",
              "name": "EnableSourceLink",
              "fullDescription": {
                "text": "SourceLink information should be present in the PDB. This applies to binaries built with the C# and MSVC compilers. When enabled, SourceLink information is added to the PDB. That information includes the repository URLs and commit IDs for all source files fed to the compiler.\r\nThe PDB should also be uploaded to a symbol server so that it can be discovered by a debugger such as Visual Studio. Developers can then step into the matching source code. Frictionless source-driven debugging provides a good user experience for consumers and also accelerates security response in the event of supply-chain compromise.\r\nSee https://aka.ms/sourcelink for more information."
              },
              "help": {
                "text": "SourceLink information should be present in the PDB. This applies to binaries built with the C# and MSVC compilers. When enabled, SourceLink information is added to the PDB. That information includes the repository URLs and commit IDs for all source files fed to the compiler.\r\nThe PDB should also be uploaded to a symbol server so that it can be discovered by a debugger such as Visual Studio. Developers can then step into the matching source code. Frictionless source-driven debugging provides a good user experience for consumers and also accelerates security response in the event of supply-chain compromise.\r\nSee https://aka.ms/sourcelink for more information."
              },
              "messageStrings": {
                "Pass": {
                  "text": "The PDB for '{0}' contains SourceLink information, maximizing engineering and security response efficiency when source code is required for debugging and other critical analysis."
                },
                "Warning": {
                  "text": "The PDB for '{0}' does not contain SourceLink information, compromising frictionless source-driven debugging and increasing latency of security response.\r\nEnable SourceLink by configuring necessary project properties and adding a package reference for your source control provider.\r\nSee https://aka.ms/sourcelink for more information."
                }
              },
              "helpUri": "https://github.com/microsoft/binskim/blob/main/docs/BinSkimRules.md#rule-BA2027EnableSourceLink"
            },
            {
              "id": "BA6002",
              "name": "EliminateDuplicateStrings",
              "fullDescription": {
                "text": "The /GF compiler option, also known as Eliminate Duplicate Strings or String Pooling, will combine identical strings in a program to a single readonly copy. This can significantly reduce binary size for programs with many string resources."
              },
              "help": {
                "text": "The /GF compiler option, also known as Eliminate Duplicate Strings or String Pooling, will combine identical strings in a program to a single readonly copy. This can significantly reduce binary size for programs with many string resources."
              },
              "messageStrings": {
                "Pass": {
                  "text": "'{0}' was compiled with Eliminate Duplicate Strings (/GF) enabled."
                },
                "Warning": {
                  "text": "'{0}' was compiled without Eliminate Duplicate Strings (/GF) enabled, increasing binary size.\r\nFor VC projects use ItemDefinitionGroup - ClCompile - StringPooling property with 'true' value.\r\nThe following modules do not specify that policy: {1}."
                },
                "NotApplicable_InvalidMetadata": {
                  "text": "'{0}' was not evaluated for check '{1}' as the analysis is not relevant based on observed metadata: {2}."
                }
              },
              "helpUri": "https://github.com/microsoft/binskim/blob/main/docs/BinSkimRules.md#rule-BA6002EliminateDuplicateStrings"
            },
            {
              "id": "BA6004",
              "name": "EnableComdatFolding",
              "fullDescription": {
                "text": "COMDAT folding can significantly reduce binary size by combining functions which generate identical machine code into a single copy in the final binary."
              },
              "help": {
                "text": "COMDAT folding can significantly reduce binary size by combining functions which generate identical machine code into a single copy in the final binary."
              },
              "messageStrings": {
                "Pass": {
                  "text": "'{0}' was compiled with COMDAT folding (/OPT:ICF) enabled"
                },
                "Warning_EnabledForDebug": {
                  "text": "'{0}' appears to be a Debug build which was compiled with COMDAT folding (/OPT:ICF) enabled.\r\nFor VC projects check ItemDefinitionGroup - Link - EnableCOMDATFolding property. That may make debugging more difficult."
                },
                "Warning_DisabledForRelease": {
                  "text": "'{0}' was compiled with COMDAT folding (/OPT:ICF) disabled, increasing binary size.\r\nFor VC projects use ItemDefinitionGroup - Link - EnableCOMDATFolding property with 'true' value."
                },
                "NotApplicable_InvalidMetadata": {
                  "text": "'{0}' was not evaluated for check '{1}' as the analysis is not relevant based on observed metadata: {2}."
                }
              },
              "helpUri": "https://github.com/microsoft/binskim/blob/main/docs/BinSkimRules.md#rule-BA6004EnableComdatFolding"
            },
            {
              "id": "BA6005",
              "name": "EnableOptimizeReferences",
              "fullDescription": {
                "text": "Optimize References can significantly reduce binary size because it instructs the linker to remove unreferenced functions and data from the final binary."
              },
              "help": {
                "text": "Optimize References can significantly reduce binary size because it instructs the linker to remove unreferenced functions and data from the final binary."
              },
              "messageStrings": {
                "Pass": {
                  "text": "'{0}' was compiled with Optimize References (/OPT:REF) enabled"
                },
                "Warning": {
                  "text": "'{0}' was compiled with Optimize References (/OPT:REF) disabled, increasing binary size.\r\nFor VC projects use ItemDefinitionGroup - Link - OptimizeReferences property with 'true' value."
                },
                "NotApplicable_InvalidMetadata": {
                  "text": "'{0}' was not evaluated for check '{1}' as the analysis is not relevant based on observed metadata: {2}."
                }
              },
              "helpUri": "https://github.com/microsoft/binskim/blob/main/docs/BinSkimRules.md#rule-BA6005EnableOptimizeReferences"
            }
          ]
        }
      },
      "invocations": [
        {
          "executionSuccessful": true
        }
      ],
      "columnKind": "utf16CodeUnits"
    }
  ]
}